> 操作系统中管理分层存储器体系的部分称为存储管理器

## 存储管理相关概念

### 地址空间

虚地址空间：目标程序所限定的地址范围也称虚空间／ 逻辑空间。（源程序经编译，或汇编后产生的逻辑空间， 是相对于‘０’地址开始的地址的集合）

![image-20241216173036531](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241216173036531.png)

内存空间：内存中物理地址的集合。

地址重定位（地址映射）：将虚拟地址变换为内存地址的过程，也称为地址重定位。

![image-20241221095502002](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241221095502002.png)

### 程序装入

1. 绝对装入方式
   * 编译程序产生绝对地址目标代码，绝对装入程序按照装入模块中的地址，将程序和数据装入内存。
   * 编译时产生绝对地址
   * 编译器负责地址转换
   * 单道程序阶段，无操作系统
2. 可重定位方式（静态重定位）
   * 编译时目标模块的地址（相对地址）从0开 始。可重定位装入程序，根据内存当时的使用情况，将装入模块装入到内存中某个位置。如果装入时对目标程序的指令和数据地址变换是在装入时一次完成，为静态重定位。
   * 装入时将逻辑地址转化为物理地址
   * 装入程序负责地址转换
   * 早期多道批处理系统
3. 动态运行时装入（动态重定位）
   * 动态运行时的装入程序，在把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而把这种地址转换推迟到程序要真正执行时进行。
   * 运行时将逻辑地址转化为物理地址
   * 运行时才进行地址转换
   * 现代操作系统

### 程序的链接

>  将经过编译或汇编后得到的一组目标模块以及它们所需要的库函数，装配成一个完整的装入模块。

   * 静态链接
     * 执行前即进行链接（包括相对地址修改，外部调用符号 改变），以后不再拆开的链接方式，链接成的完整装入模块， 运行时直接装入内存。
   * 装入时动态链接
     * 目标模块在装入内存时，边装入边链接。
   * 运行时动态链接
     * 目标模块的链接推迟到执行时才进行。

### 内存保护

1. 基地址-界限寄存器法（硬件）
   * 进程1不能访问os和其他进程的地址空间![image-20241218105607251](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241218105607251.png)
2. 保护键法（软件）
   * 为每一个被保护存储块分配一个单独的保护键，在PSW 中设置相应的保护键开关字段，对不同的进程赋予不同的开 关代码和被保护的存储块中的保护键相匹配。
   * ![image-20241216182238675](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241216182238675.png)

## 连续存储管理方式

>  连续分配：指为用户分配的必须是一个连续的内存空间

### 单一分区分配

> 只支持单道程序，内存分为系统区和用户区，用户程序放在用户区

### 固定多分区分配

> 支持多道程序，内存用户空间分为若干个固定大小的分区，每个分区只能装入一道作业。

1. 两种分区方式
   * 分区大小相等
   * 分区大小不等

### 动态分区分配

#### 内存分配算法

* ##### 首次适配算法（First fit）

  * ![image-20241218113308397](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241218113308397.png)

  * eg: 请求一个6K大小的分区
  * ![image-20241216183921976](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241216183921976.png)

* ##### 下次适配算法（Next fit）

  在first fit基础上，从上次搜索结果为止开始搜索。

* ##### 最佳适配算法（Best fit）

  * ![image-20241218113517806](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241218113517806.png)

* ##### 最差适配算法（Worst fit）

  * ![image-20241218113705889](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241218113705889.png)

* ##### 快速适配算法（Quick fit）

  将常用长度的空闲区有组织地存放

## 非连续分配存储管理方式

### 动态重定位分区分配

## 交换技术

> 交换技术的设计思想:内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中(某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)
>
> * 暂时换出外存等待的进程状态为挂起状态(挂起态，暂停)
> * 挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态

### 处理内存超载的两种方法

1. 交换技术
2. 虚拟存储技术

### 空闲内存管理

#### 位图及链表的存储管理

>  一段有5个进程和3个空闲区的内存
>
> * 刻度表示内存分配的单元
> * 阴影区域表示空闲

![image-20241216183238729](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241216183238729.png)

### 使用链表的存储管理

结束进程X时与相邻区域的四种组合

![image-20241216183351450](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241216183351450.png)

## 虚拟存储

> 基本思想: 程序、数据、堆栈占用空间的总和超过了实际物理内存的大小。
>
> 通常的策略:
>
> * 覆盖技术
> * 分页

### 覆盖技术

> 思想：将程序划分为多个段（多个模块），常用的段常驻内存，不常用的段在需要时调入内存。
>
> 内存分为一个“固定区”和多个“覆盖区”。
>
> * 需要常驻内存的段放在固定区，调入后不再调出（除非程序运行结束）
> * 不常用的段放在覆盖区，需要用到时调入内存，用不到时调出。

![image-20241216184437082](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241216184437082.png)

* (a)程序的模块划分
* (b)程序覆盖使用内存 

> 不采用覆盖技术所需内存：A(20K)+B(50K)+C(30K)+D(20K)+E(40K)+F(30K)=190K
>
> 采用覆盖技术后使用内存: A(20K)+B(50K)+E(40K)=110K

![image-20241218105332024](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241218105332024.png)

### 分页存储管理

#### 分页原理

1. 划分
   * 用户进程的虚地址空间划分为页
   * 物理空间划分为与页大小相同的块
   * 页的大小= 块的大小
2. 分配
   * 将空闲块分配给逻辑页
3. 地址映射
   * 借助页表实现地址映射
4. 页面置换
   * 如果没有足够的物理块，将执行页面置换

### 页表

> 页表面临的两个主要问题:
>
> 1. 页表可能非常的大
>    * 例如采用32-bit or 64-bit 地址结构的计算机
> 2. 地址映射必须快速完成
>    * 一条典型的指令通常要访问1、2次页表.(2,3 次 内存访问)

#### TLB（快表）

>  Translation Lookaside Buffer 地址址转换后备缓冲

* 提高变换速度→用高速缓冲存储器存放常用的页表项

### 页面置换算法

> 1. 页面发生缺页中断时:
>    * 必须选择一个页面换出
>    * 为即将调入内存的页面腾出空间
> 2. 已修改的页面必须首先保存，未修改的页面只需要覆盖即可
>
> 3. 不要选择频繁使用的页面置换出内存
>    * 很可能很短时间内又要被调入内存
>    * 最求更少的缺页率
> 4. 缺页中断未必发生页面置换，若有可用的空闲内存块就不用进行页面置换

#### 最优页面置换算法（OPT（optimal））

> 置换未来不再需要或最远的将来才会使用的页面
>
> * 最优但是不可实现
>
> 可作为其他置换算法性能的评价标准

#### 先进先出页面置换算法（FIFO）

> 在表头的最久进入页面被置换出内存
>
> 缺点:
>
> * 在内存中最久的页面常常可能就是频繁使用的

* Belady‘s 现象（Belady异常）：当为进程分配的物理块数增大时，缺页次数不增反减的现象

* 只有FIFO会产生Belady异常
* FIFO虽然实现简单，但该算法与实际进程运行时的规律不适应，因为先进入的页面可能经常被访问，因此算法性能差。

#### 第二次机会页面置换算法（SCR）

> 比FIFO有大的改善

算法描述：

* 按先进先出的方法排列的页面
* 设置一个访问位
* 当淘汰一个页面时，要检查其访问位：若访问位是1，给它第二次机会，选择下一个FIFO页面，并将其访问位置为0；若访问位是0，则淘汰它。
* 另外，访问到访问位为0的页面，将其访问位重新置为1

#### 时钟页面置换算法（Clock）

![image-20241222122342749](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241222122342749.png)

#### 最近最少使用页面置换算法(LRU)

>  假设最近使用的页面很快又被使用：
>
> * 置换很长时间没被使用的页面

需要在内存中维护一个所有页面的链表

* 最近最多使用的页面在表头，最近最少使用的页面在表尾
* 每次访问内存时都必须要更新整个链表!!

另外一种做法就是在每个页表项中设置一个计数器 （硬件的实现方法）

* 每个页表项中添加一个计数器
* 硬件矩阵

#### 最近未使用页面置换算法（NRU）

> 每个页面都设置一个访问位和修改位
>
> * 当页面被访问或修改时即设置访问位或修改位
>
> 页面被分类成：
>
> * 未被访问, 未被修改
> * 未被访问, 已被修改
> * 已被访问, 未被修改
> * 已被访问, 已被修改
>
> NRU 算法随机的选择页面淘汰之
>
> * 从类编号最小的非空类中挑选一个页面
>
> LRU的很粗糙的近似

#### 工作集页面置换算法

#### 工作集时钟页面置换算法

#### eg

某程序在内存中分配**三个**页面，初始为空，页面走向 为4，3，2，1，4，3，5，4，3，2，1，5。 求分别采用OPT(最优页面置换算法)、FIFO、LRU、栈式算法作为页面置换算法时的缺页次数及缺页率？

注：为了方便比较，以下页面按调入先后进行了排序

1. OPT

   | OPT  | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
   | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
   | 页1  | 4    | 3    | 2    | 1    | 1    | 1    | 5    | 5    | 5    | 2    | 1    | 1    |
   | 页2  |      | 4    | 3    | 3    | 3    | 3    | 3    | 3    | 3    | 5    | 5    | 5    |
   | 页3  |      |      | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    |
   | 缺页 | P    | P    | P    | P    |      |      | P    |      |      | P    | P    |      |

   7次缺页，缺页率7/12

2. FIFO

   | FIFO | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
   | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
   | 页1  | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 5    | 5    | 2    | 1    | 1    |
   | 页2  |      | 4    | 3    | 2    | 1    | 4    | 3    | 3    | 3    | 5    | 2    | 2    |
   | 页3  |      |      | 4    | 3    | 2    | 1    | 4    | 4    | 4    | 3    | 5    | 5    |
   | 缺页 | P    | P    | P    | P    | P    | P    | P    |      |      | P    | P    |      |

   9次缺页，缺页率9/12

3. LRU

   | LRU  | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
   | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
   | 页1  | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
   | 页2  |      | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    |
   | 页3  |      |      | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    |
   | 缺页 | P    | P    | P    | P    | P    | P    | P    |      |      | P    | P    | P    |

   10次缺页，缺页率10/12

4. 栈式算法

   | 栈式算法 | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
   | -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
   | 页1      | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
   | 页2      |      | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    |
   | 页3      |      |      | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    |
   | 缺页     | P    | P    | P    | P    | P    | P    | P    |      |      | P    | P    | P    |

​       10次缺页，缺页率10/12

## 分段

### 分段存储管理方式

原理：将虚地址空间按逻辑结构关系分成若干段，每段有自己的段名，且都是从0地址开始的地址空间，段的长短可变，划分 后的地址结构为：![image-20241220142856772](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241220142856772.png)



## 分页系统中的设计问题

局部置换：发生缺页时只能选进程自己的物理块进行置换

全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程

![image-20241222134439713](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241222134439713.png)

抖动（颠簸）现象：刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存。

* 主要原因是分配给进程的物理块不够。

## 页面大小

1. 小页面

   优势

   * 更少的内部碎片
   * 更加灵活适合各种程序结构和数据段
   * 减少内存中没用的程序 

   不足

   * 程序需要更多页面，更大的页表

2. 系统开销取决于页表大小和内部碎片

   ![image-20241222143046057](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241222143046057.png)

## 内存映射文件机制

* 机制思想：进程通过一个系统调用将一个文件映射到其虚拟地址空间的一部分，访问这个文件就像访问内存中的一个大数组，而不是对文件进行读写
* 在多数实现中，在映射共享的页面时不会实际读入页面的内容，而是在访问页面时，页面才会被每次一页的读入，磁盘文件则被当作后备存储
* 当进程退出或显式地解除文件映射时，所有被修 改页面会写回文件



## 思考题

1. 存储管理的功能
   * 内存分配：合理分配内存资源给不同的进程。
   * 内存保护：保护的目标是防止一个进程非法访问另一个进程的内存空间或操作系统的关键区域，保障系统的稳定性和安全性。如：基地址-界限寄存器保护法、保护键法等
   * 内存共享：允许不同进程共享某些内存区域，从而实现进程间的通信，特别适用于需要高效交换大量数据的场景。
   * 内存扩充：通过操作系统的虚拟内存技术，使得进程可以使用比实际物理内存更大的内存空间。
   * 地址映射：地址映射是虚拟地址与物理地址之间的转换过程，操作系统利用硬件（内存管理单元，MMU）和软件（页表、段表等）来实现虚拟地址空间到物理地址空间的映射。

2. 存储空间和地址重定位（地址映射）
   * [存储管理相关概念](#存储管理相关概念)

3. 分区存储管理：固定、动态、动态重定位。如何进行分配，映射，保护机制以及所使用的数据结构。
   * 固定分区存储管理
     * 内存划分成固定大小的分区，在操作系统启动时确定，之后不会改变。每个分区只能容纳一个进程。
     * 虚拟地址到物理地址的映射：虚拟地址空间是由进程的起始地址和大小决定的。虚拟地址中的偏移量对应物理内存中的地址，整个虚拟地址空间直接映射到物理内存的一个固定大小的区域。
     * 内存保护：每个分区对应一个进程，进程的内存空间不允许越界访问其他进程的空间。操作系统通过硬件的内存管理单元（MMU）来限制进程对物理内存的访问。
     * 数据结构：分区表
   * 动态分区存储管理
     * 动态分配：当一个进程请求内存时，操作系统根据进程的大小动态地分配一块连续的内存区域。采用合适分配算法[内存分配算法](#内存分配算法)
     * 
   * 动态重定位分区存储管理

4. 动态分区分配算法
   * [内存分配算法](#内存分配算法)

5. 虚拟存储的概念

6. 覆盖和对换技术的原理、特点
   * [覆盖技术](#覆盖技术)

7. 页式存储分配主要是解决什么问题

8. **分页原理；逻辑地址到页号和页内偏移量的转换方法（两种：公式和二进制）**
   * [分页原理](#分页原理)

9. 页式存储的地址映射过程

10. 二级页表的一级、二级页号和页内偏移量的计算 

11. 请求分页原理；局部性原理；页表结构与缺页中断 

12. **请求分页的地址变换**

13. **页面转换算法（OPR FIFO LRU clock 时钟 P119）**
    * [页面置换算法](#页面置换算法)

    * ![image-20250107130310469](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20250107130310469.png)

    * | FIFO | 0    | 1    | 7    | 2    | 3    | 2    | 7    | 1    | 0    | 3    |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 0    | 0    | 1    | 7    | 2    | 3    | 3    | 3    | 3    | 0    | 0    |
      | 1    |      | 0    | 1    | 7    | 2    | 2    | 2    | 2    | 3    | 3    |
      | 2    |      |      | 0    | 1    | 7    | 7    | 7    | 7    | 2    | 2    |
      | 3    |      |      |      | 0    | 1    | 1    | 1    | 1    | 7    | 7    |
      | 6次  | P    | P    | P    | P    | P    |      |      |      | P    |      |

    * | LRU  | 0    | 1    | 7    | 2    | 3    | 2    | 7    | 1    | 0    | 3    |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 0    | 0    | 1    | 7    | 2    | 3    | 3    | 3    | 3    | 0    | 3    |
      | 1    |      | 0    | 1    | 7    | 2    | 2    | 2    | 2    | 2    | 0    |
      | 2    |      |      | 0    | 1    | 7    | 7    | 7    | 7    | 7    | 7    |
      | 3    |      |      |      | 0    | 1    | 1    | 1    | 1    | 1    | 1    |
      | 7次  | P    | P    | P    | P    | P    |      |      |      | P    | P    |

    * ![image-20250107131209206](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20250107131209206.png)
      * (a):2
      * (b):3
      * (c):1
      * (d):2

14. 分配置换策略；抖动 

    * 抖动（颠簸）现象：刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存。

15. 分段存储管理的目的

16. 分段存储的地址结构 

17. 分段存储的地址变换过程

18. 段页式存储管理原理和地址变换过程 

19. 请求段页式存储管理原理

20. 内存分配算法![image-20250107124554220](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20250107124554220.png)

    * first fit:(地址递增排序)
      * (a)20MB
      * (b)10MB
      * (c)18MB
    * best fit(空闲区排序):
      * (a)12MB
      * (b)10MB
      * (c)9MB
    * worst fit(空闲区排序):
      * (a)20MB
      * (b)18MB
      * (c)15MB
    * next fit（在first fit 基础上，从上次搜索结束为止开始搜索）:
      * (a)20MB
      * (b)18MB
      * (c)9MB

21. 地址转换![image-20250107125704260](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20250107125704260.png)

![image-20250107125755474](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20250107125755474.png)

* (a)8192+20=8212
* (b)4100
* (c)24576+8300-8192=24684

22. 

## 思考题 2

1. 如何理解虚拟存储与真实的物理内存间的关系？
2. 分区存储管理用在专用的，具有特定工作任务的，嵌入式系统中，可不可行？
   *  分区存储管理用在专用的、具有特定工作任务的嵌入式系统中是可行的。
     * 分区存储管理支持多道程序运行，可以提高存储器的利用率，并且管理相对简单，不需要太多的软硬件支持
     * 分区存储能够消除存储设备内部的垃圾回收，减少写放大，节省成本，同时能大大减小 映射表大小，提升系统性能。
     * 在嵌入式存储设备中，分区存储的使用再加上成熟的SLC缓存机制，可以弥补QLC寿命短和性能差两大短板，让QLC应用到嵌入式存储设备上变得可行。

3. 三种放置策略中，最佳适应法是不是比最坏适应法或首次适应算法性能要优异？内存利用率呢？为什么？
4. 内存覆盖技术有哪些缺点？
5. 内存在分配过程中产生碎片的本质是什么？
   * 
