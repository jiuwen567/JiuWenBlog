# 操作系统的概念

## 操作系统的定义

操作系统是一组控制和管理计算机软、硬件资源， 合理组织计算机工作流程，以及方便用户的程序的集合

### 理解 

* 一个扩展了的机器
  * 提供方便接口，隐藏硬件细节。 

* 资源管理器
  * 实现多道程序，多用户的资源管理

## 操作系统的历史

### 真空管、插板（手工操作、无操作系统）阶段

### 电子管、批处理系统阶段

* 单道批处理系统
  * 每次只调入一个作业进入内存，并运行。
* 多道批处理系统
  * 每次可调入多个作业进入内存并运行。

### 集成电路、多道程序（分时）系统

### 现代操作系统

## 操作系统的分类

### 批处理系统

### 分时系统

### 实时系统

### 通用操作系统及个人操作系统

### 嵌入式操作系统

### 网络操作系统

### 分布式操作系统

## 操作系统的功能

* 处理机管理：进程控制、同步、通信，处理机调度 
* 存储器管理：内存分配，内存保护，地址映射，内存扩充 ．
* 设备管理：缓冲管理，设备分配，设备处理（驱动程序） 
* 文件管理：外存管理，目录管理，文件的读/写和保护
*  用户接口：系统调用（程序接口），命令接口，图形接口 。
* 作业管理：作业组织，调度

## 计算机的组成

### 处理器

工作模式:

* 内核模式（核心态）:CPU可以执行指令集中的所有指令，并使用硬件的每种功能。 
* 用户模式（用户态）:仅仅允许执行指令集的一个子集和访问所有功能的一个子集。

### 存储器

![image-20241202115614341](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241202115614341.png)

### I/O设备

## 系统启动

系统启动即是将操作系统读入内存的工作。

* 实模式：16位实模式，为绝对地址。支持一个20位的存储地址空间，无分页 机制和实时多任务概念；

* 保护模式：引入段模式、页模式，并为段模式提供保护机制，也就说一个段 的描述符需要规定对自身的访问权限（Access）。为此引入了GDT（LDT）， 用以实现分段管理，达到32位/64位寻址空间；

过程： 

* 启动BIOS，准备实模式下的中断向量表及中断服务程序 

* 加载操作系统内核程序并为保护模式做准备 

* 进入保护模式，为main函数的调用做准备 

* 内核初始化 

* 生成init进程

* 系统初始化，shell命令文本的执行 

* 生成各终端进程

## 用户接口

* ### 命令接口

  提供给用户命令的方式控制系统运行 

  常用shell命令接口： 

  * 系统访问：login,   logout,   exit 
  * 编辑和文件管理：vi,  cat,  pr,   cp,   mv,   rm  
  * 目录操作命令：ls,  mkdir,  pwd,   cd,   rmdir,  chmod 
    * eg. $chmod go+rw file 
  * 编译，链接命令：cc,  link 
  * 日期命令：date

  特殊命令： 

  * 后台命令：＆ 
    * eg.       `$cc  a.c& ．`

  *  `文件名通配符：＊，？ `

  *  `重定向符号：＜， ＞，＞＞`
    * eg.    $a>b $a**>b ．**

  * 管道命令：`｜`
    * 一个命令的执行结果直接放入系统缓冲区，作为下一个命令 的输入。

  * 率波器命令：grep, sort

* ### 系统调用（程序接口）

  用户程序使用该接口访问系统资源，从而获取 操作系统服务。

  #### 常用系统调用

  与设备有关的系统调用： open,   close,    read,    write 

  与文件系统有关的系统调用： open,   close,    read,    write,    creat,   unlink 

  与进程控制有关的系统调用： fork,   wait,    exit,   getpid,   getppid,   getpriority,   nice,   kill,   signal,   pause,    pipe，lockf

  #### 系统调用fork示例（Linux或macos）

  ```c
  main()
  {
   int i ;
   while((i=fork())==-1)  ;
   printf(“i=%d\n”,i);
   if ( i ) printf(“It is a parent process!\n”);
   else printf(“It is a child process!\n”);
  }
  ```

  fork()返回值：

  *  －１；创建子进程失败
  * ０；返回到子进程中执行 
  * ＞０；返回

  在使用 `fork()` 创建子进程时，父进程和子进程是 **并发执行** 的，它们各自独立运行。**谁先执行** 取决于操作系统的调度器，它会根据当前的系统负载、进程优先级、CPU 调度策略等因素来决定哪个进程先执行

  > **父进程**和**子进程**都是由`fork()`创建的。`fork()`函数会返回两次：
  >
  > - 在父进程中，`fork()` 返回一个大于 0 的值（即子进程的 PID）。
  > - 在子进程中，`fork()` 返回 0。

* Linux下实际代码

  ```c
  #include <stdio.h>
  #include <unistd.h>  // 引入 fork() 函数定义
  
  int main()
  {
      int i;
      while((i = fork()) == -1)  ;  // 直到fork成功为止，若失败继续尝试
      printf("i=%d\n", i);
      if (i)
          printf("It is a parent process! pid: %d\n",getpid());
      else
          printf("It is a child process! pid: %d\n",getpid());
      return 0;
  }
  ```

  ![image-20241204144629105](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241204144629105.png)

* ###  图形用户接口

  * 为用户提供的图形化的操作界面

# 中英名词对照

* IR instruction register 指令寄存器
* AR address register 地址寄存器
* ALU arithmetic and logic unit 算术逻辑单元
* MAR Memory Address Register 地址寄存器
* MBR Memory Buffer Register 存储器缓冲寄存器
* ISA Industry Standard Architecture 工业标准体系结构
* cat catenate 链接文本文件
* pwd 将当前目录的全路径名称（从根目录）写入标准输出
* CMS conversational monitor system 会话监控系统
* BIOS Basic Input Output System 基本输入输出系统