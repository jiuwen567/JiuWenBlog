## 并发vs并行

并发：两个或多个事件在同一个**时间间隔**之内同时发生

并行：两个或多个事件在**同一个时刻**同时发生

## 进程VS 程序

* 进程是动态的，而程序是静态的 
* 进程可以并发，而程序则没有 
* 进程是资源竞争的基本单位

联系：一个程序可以生成多个不同的进程

## 进程

### 进程的层次结构

* 系统中除根进程外，每个进程都有且只有一个父进程
* 每个子进程均由它的父进程创建 
* 一个父进程可以有多个子进程

### 进程创建原因

* 系统初始化
* 正在执行的进程调用创建进程的系统调用
* 用户请求创建一个进程 
* 批处理作业的初始化

### 进程的终止

* 正常退出(voluntary) 
* 出错退出(voluntary) 
* 严重错误(involuntary) 
* 被其他进程杀死(involuntary)

### 守护进程

> Daemons（守护进程）--Processes that stay in the  background to handle some activity such as  email, Web pages, news,printing,and son on are  called daemons.

### 进程实现（静态描述）

#### 进程控制块ＰＣＢ

* 用来标识进程存在 于系统中的唯一的实体，部分或全部常驻内存

* 系统用ＰＣＢ反映进程的动态特征， 

  内容包括： 

  * 描述信息：进程名（标识号），用户名（标识号），家族链 
  * 控制信息：状态，优先级，内存始址，计时，通信信息 
  * 资源管理信息：内存、设备等信息 ．ＣＰＵ现场保护机构：寄存器

##### 主要字段

**![image-20241205180143343](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241205180143343.png)**

### 进程状态及其转换

* 运行态：正在使用CPU 
* 就绪态：可运行，指获取了除CPU之外的所有资源的进程 状态。 
* 阻塞态：不可运行，且只能由其他外部事件发生而唤醒的状态

![image-20241205180650873](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241205180650873.png)

### 进程控制

系统使用具有特定功能的程序段来创建，撤消进程及完成进程之间状态转换

#### 原语

> a  single ,  indivisible  atomic  action （系统态下执行的某些具有特定功能的程序段） ．

* 机器指令级：不允许中断 
* 功能级：不允许并发执行

#####  用于进程控制的原语

创建原语，撤消原语，阻塞原语，唤醒原语

## 线程

线程是轻量级的进程，它是一个进程内的基本调度单位，有自己的程序计数器、寄存器及堆栈。

### 多线程与多进程

* 多线程系统允许多个线程共享一个进程的地址空间、打开文件、全局变量等资源。

* 多进程系统允许多个进程共享物理内存、磁盘、打印机等资源。

### 线程与进程

* 进程是资源管理的基本单位

* 线程是调度的基本单位

### 引入线程的原因

* 伪并行，进一步提高并发度 
*  更小的系统开销 
*  更高的性能 
* 有利于在多CPU系统中实现真正的并行

## 进程通信

### 并发执行的进程间相互制约关系

* 间接制约：诸进程对共享资源的使用通过系统来协调，使得进程间执行速度相互影响。（进程间互斥）
* 直接制约：诸进程自行使用共享资源或由进程合作引起，某一进程直接通过某机制发消息给其他进程，从而直接影响其他进程的执行。（进程间同步）

### 基本概念

* 临界资源（竞争条件）：一次只允许一个进程使用的资源
* 临界区：在每个进程中，访问临界资源的那部分代码（那段程序）

### 进程通信方式

* 低级通信：同步&互斥

* 高级通信：管道通信、消息队列、共享内存、网络通信

## 互斥

> 不允许两个以上的共享该资源的并发进程同时进入临界区，称为互斥

### 并发进程互斥执行准则

* 不假设各并发进程的相对执行速度 
* 出于临界区外的进程不能阻止其他进程进入临界区 
* 任何时刻只允许一个进程处于临界区中 
* 不能使进程在临界区外永远等待

### 互斥的实现

1. 关中断法：每个进程进入临界区后先关中断，离开前开中断

* 缺点：系统可能终止 ．多CPU时，无用 

2. 加锁法：用锁变量来表示临界区是否可用

* 加锁后的临界区描述如下： 

```
lock(key[s]) 
<临界区>  
unlock(key[s])    //s为临界区类名 //key[s]为锁变量，为1表示临界区 //可用，为0表示临界区不能使用
```

* eg: 

  ```c
  lock(key[s])
  {
  L:
      if key[s] = 0 
      then goto L 
      else key[s] = 0
  }
  
  unlock(key[s]){
      key[s] = 1
  } 
  
  PA(){
      L1 : lock(key[s]) < s >
      unlock(key[s]) goto L1
  }
  
  PB()
  {
  L2:
      lock(key[s])<s>
      unlock(key[s]) goto L2
  }
  ```

* 缺点：

  * 不断循环测试，CPU费时 
  * 存在不公平现象

3. 严格的轮转法：用标志严格控制轮流使用临界区

   ```c
   PA()
    {
       
    while(true) {
        
    while(turn!=0);   //wait
    critical_region();
    turn=1;
    noncritical_region();
        
    }
    
    }
    
    PB()
    {
        
    while(true) {
        
    while(turn!=1);   //wait
    critical_region();
    turn=0;
    noncritical_region();
        
    }
        
    }
   ```

* 缺点：当一个进程比另一进程慢很多时不好

4. Peterson解决方案

   ```c
   #define False 0
   #define True 1
   #define N 2 // 两个进程
   
   int turn;
   int interested[N]; // 谁想进入临界区，对应位置置为1
   
   void enter_region(int process)
   {
       int other;
       other = 1 - process;
       interested[process] = True; // 该进程想要申请得到资源
       turn = process;             // 倾向于该进程
       while (turn == process && interested[other] == True);//其他进程想要进入时阻塞
   }
   void leave_region(int process){
       interested[process] = False;
   }
   ```

   * `turn` 的作用是保证两个进程在同时请求进入临界区时能按照顺序依次进入，从而避免死锁和饥饿，确保系统的公平性。

5. 信号量法

   * 信号量：是ＯＳ中表示资源的物理实体，是一个与队列相关的 整型变量，其值仅由down，up原语改变

   * 信号量的表示意义： 设s为信号量，则： 

     * 当s>=0时，表示可供并发进程使用的资源实体数 

     * 当s < 0时，表示正在等待使用资源的进程数

   * Ｐ、Ｖ原语的操作等同down、up原语操作

   * 信号量实现互斥

     ```c
     //设一个互斥的信号量sem
     //描述：S为临界区的类名
     ＰA：
     …
     down(sem)
      <S> 
     up(sem)
      …
     ＰB：
     …
     down(sem)
      <S> 
     up(sem)
     ```

## 管程

* 一种更为高级的同步原语，更便于使用，管程的互斥由编译 器负责，使用者只需将所有临界区转换为管程即可。 
* 一个管程是由过程、条件变量及数据结构等组成的特殊模块 或软件包。进程仅能通过管程访问其中的数据结构。 
* 管程的特性：任一时刻管程中只能有一个活跃进程

## 进程同步

>  异步环境下，一组并发进程因直接制约而相互发送消息， 相互合作，相互等待，使各进程按一定速度执行的过程

### 同步的实现

1. 消息名法

   > 为同步进程间发送的事件或消息赋予一个唯一的消息名，
   >
   > 用：
   >
   > wait（）表示进程等待合作进程发来的消息)
   >
   > signal（）表示向合作进程发送消息

   描述：

   * ```c
     //设消息名Bufempty表示Buf为空，Buffull表示Buf满
     //初始化：Bufempty=true,  Buffull=false
     
     Pc:
     A:    
     wait(Bufempty)
     caculate
     buf <- result
     Bufempty <- false
     signal(Buffull)
     Goto  A
        
     Pp:
     B:    
     wait(Buffull)
     print 
     buf <- null
     Buffull <- false
     signal(Bufempty)
     Goto  B
     ```

2. 信号量法

   ```c
   //SA表示进程Pc的资源信号量，即buf为空，可放数据，初始化为SA=1；
   //SB表示buf中有数据，初始化为SB=0；
   
   Pc:
    A:  caculate  next  number
    buf <- result 
   count=count-1 
   V(SB)
    P(SA)
    if  
   count=0  then  destroy(Pc) 
   else  goto  A
       
   Pp:
    B:    P(SB)
    print <- buf
    V(SA)
    print the last number
    if  count=0  then 
   destroy(Pp)
    else  goto  B
   
   ```

## 进程高级通信

> 消息传递 
>
> 1. 引入:
>
> * 信号量需要编程语言支持.
>
> *  信号量在网络环境下不可用 •
>
> 2. 实现: 
>
> * send(destination, &message) 
> * receive(source, &message)

### 用N条消息实现的生产者-消费者问题

```c
#define N 100

void producer(){
    int item;
    message m;
    while (TRUE)
    {
        item = produce_item(); // 生成一个商品
        receive(consumer, &m); // 从消费者接收消息（消费者可能发送一个空的消息，表示消费者准备好接收新的商品）
        build_message(&m,item);  // 使用生成的商品构建消息
        send(consumer, &m); //发送消息给消费者
    }
    
}

void consumer(){
    int item;
    message m;
    for (int i = 0; i < N; i++)
    {
        send(producer,&m) // 向生产者发送初始消息，可能是空消息，表示消费者准备好了
    }
    
    while (TRUE)
    {
        receive(producer, &m); // 从生产者接收商品消息
        item = extract_item(&m); // 从消息中提取商品
        send(producer,&m); // 消费者发送消息给生产者，可能表示消费者可以继续消费
        consume_item(item);   //消费商品
    }

}
```

### 生产者-消费者问题

```c
#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer()
{
    int item;
    while (TRUE)
    {
        item = produce_item();
        down(&empty);
        down(&mutex); //进入临界区
        insert_item(item); //放入数据到缓冲区
        up(&mutex); // 离开临界区
        up(&full);
    }
}

void consumer()
{
    int item;
    while (TRUE)
    {
        down(&full);
        down(&mutex); //进入临界区
        item = remove_item(); //从缓冲区取数据
        up(&mutex); // 离开临界区
        up(&empty);
        consume_item(item) //消费商品
    }
}
```

### 哲学家就餐问题

> **哲学家就餐问题**是经典的并发与同步问题，通常用来描述多个进程如何共享资源的情景。在这个问题中，哲学家们坐在餐桌旁，他们的任务是思考、拿起两根筷子（共享资源），然后吃饭。哲学家们必须交替进行思考、吃饭、和放下筷子(叉子)。然而，如果哲学家们不遵循适当的规则，就会出现以下几种问题：
>
> 1. **死锁（Deadlock）**：所有的哲学家都拿着一根筷子并且等待另一根筷子，这样他们就都无法继续吃饭。
> 2. **饥饿（Starvation）**：某些哲学家永远不能获得足够的筷子来吃饭，而是被其他哲学家不断抢占。
> 3. **竞态条件（Race Condition）**：不同哲学家对共享资源的访问会出现冲突，导致不一致的状态。

#### 问题描述

![image-20241208115728710](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241208115728710.png)

- **资源**：每个哲学家有两根筷子（叉子），坐在圆桌旁。

- 任务

  ：每个哲学家反复进行以下操作：

  - 思考（Think）
  - 拿起两根筷子（Pick up both chopsticks）
  - 吃饭（Eat）
  - 放下筷子（Put down both chopsticks）

- **条件**：每根筷子是共享的，任何两位哲学家不能同时使用同一根筷子。

#### 错误的做法

```c
#define N 5  //哲学家数量

void philosopher(int i) //i:哲学家编号 from 0 to 4
{
    while (TRUE)
    {
        think();
        //拿左右两边的筷子
        take_fork(i);
        take_fork((i+1)%N);
        eat();
        put_fork(i);
        put_fork((i+1)%N);
    }
}

```

两个哲学家同时试图拿起两根筷子时，死锁会发生!!

##### 死锁的产生：

死锁发生的条件是**循环等待**，即一组进程在等待资源时，形成一个环路。具体来说：

1. 假设所有哲学家同时开始尝试拿筷子。
2. 哲学家 `0` 先拿起了 **左边的筷子 `fork[0]`**。
3. 然后，哲学家 `1` 也拿起了 **左边的筷子 `fork[1]`**，哲学家 `2` 拿起了 **左边的筷子 `fork[2]`**，依此类推。
4. 然后，哲学家们开始尝试拿右边的筷子：
   - 哲学家 `0` 尝试拿 **右边的筷子 `fork[1]`**（被哲学家 `1` 拿走了）。
   - 哲学家 `1` 尝试拿 **右边的筷子 `fork[2]`**（被哲学家 `2` 拿走了）。
   - 以此类推，直到哲学家 `4` 尝试拿 **右边的筷子 `fork[0]`**（被哲学家 `0` 拿走了）。

##### 形成循环等待：

此时，所有哲学家都已经拿到了 **一根筷子**，但每个哲学家都在等待**另一根筷子**。具体来说：

- 哲学家 `0` 拿了 `fork[0]`，但在等待 `fork[1]`。
- 哲学家 `1` 拿了 `fork[1]`，但在等待 `fork[2]`。
- 哲学家 `2` 拿了 `fork[2]`，但在等待 `fork[3]`。
- 哲学家 `3` 拿了 `fork[3]`，但在等待 `fork[4]`。
- 哲学家 `4` 拿了 `fork[4]`，但在等待 `fork[0]`。

> ##### **死锁发生的条件**：
>
> 死锁的经典条件通常包括以下四个条件（叫做 **死锁的必要条件**）：
>
> 1. **互斥条件**：每个资源（这里是筷子）只能被一个哲学家使用。
> 2. **占用并等待条件**：哲学家已经占用了一个筷子，并等待获取另一个筷子。
> 3. **不剥夺条件**：已经获取的筷子不能被强制剥夺，只有哲学家自己放下筷子。
> 4. **循环等待条件**：存在一个哲学家等待另外一个哲学家的筷子，形成一个环路。

#### 解决方案1

>  让 **偶数编号的哲学家** 先拿 **左筷子**，然后再拿 **右筷子**；而 **奇数编号的哲学家** 先拿 **右筷子**，再拿 **左筷子**。这样可以避免所有哲学家同时拿起一根筷子并阻塞，从而避免死锁。

实现：

```c
#define N 5  // 哲学家数量

void philosopher(int i) //i:哲学家编号 from 0 to 4
{
    while (TRUE)
    {
        think();
        
        // 偶数编号哲学家先拿左筷子，再拿右筷子
        if (i % 2 == 0) {
            take_fork(i);
            take_fork((i + 1) % N);
        }
        // 奇数编号哲学家先拿右筷子，再拿左筷子
        else {
            take_fork((i + 1) % N);
            take_fork(i);
        }
        
        eat();
        put_fork(i);
        put_fork((i + 1) % N);
    }
}

```

#### 解决方案2-资源分配策略

> 使用了 **信号量（semaphore）** 和 **进程状态管理** 来避免死锁和饥饿问题。它属于 **使用条件变量和互斥锁的同步解决方案**，是一种基于 **状态机** 的解决方案

##### 1. **状态管理**

每个哲学家都有 3 种状态：

- **THINKING**：哲学家正在思考，不需要任何筷子。
- **HUNGRY**：哲学家正在等待筷子（已经准备好吃饭）。
- **EATING**：哲学家正在吃饭，正在使用两根筷子。

##### 2. **信号量**

- **`mutex`**：用于保护对共享资源（`state[]` 数组）的访问，确保在修改状态时互斥。
- **`s[i]`**：是每个哲学家的信号量。每个哲学家的 `s[i]` 信号量控制哲学家的进程何时能继续执行（即什么时候能开始吃饭）。它的作用是当哲学家获得两根筷子时，它会被释放（`up(&s[i])`），哲学家就可以继续执行。

##### 3. **`take_fork(i)`**：尝试拿起左右两边的筷子

- **进入临界区**：通过 `down(&mutex)`，保护 `state[i]` 的修改。
- **更改状态为 HUNGRY**：哲学家将自己的状态设置为 **HUNGRY**，表示他想吃饭了。
- **尝试吃饭**：调用 `test(i)` 来检查该哲学家是否能够拿起两根筷子。
- **退出临界区**：通过 `up(&mutex)`，释放互斥锁。
- **阻塞自己**：如果哲学家不能同时拿到两根筷子（即左右两边的哲学家正在吃饭），则阻塞自己，等待 `s[i]` 信号量。

##### 4. **`put_fork(i)`**：放下两根筷子

- **进入临界区**：同样使用 `down(&mutex)` 来保护对 `state[]` 数组的修改。
- **更改状态为 THINKING**：哲学家吃完饭后，将自己的状态设置为 **THINKING**。
- **检查左、右邻居**：调用 `test(LEFT)` 和 `test(RIGHT)` 来检查左邻居和右邻居是否能够开始吃饭。如果他们处于 **HUNGRY** 状态并且没有在吃饭，那么就可以让他们开始吃饭。
- **退出临界区**：通过 `up(&mutex)` 来释放互斥锁。

##### 5. **`test(i)`**：判断哲学家是否可以吃饭

- **检查条件**：只有当哲学家处于 **HUNGRY** 状态，且左边和右边的哲学家都没有在吃饭时（`state[LEFT] != EATING && state[RIGHT] != EATING`），该哲学家才能开始吃饭。
- **更新状态**：如果条件满足，则将哲学家的状态改为 **EATING**，并通过 `up(&s[i])` 释放哲学家的信号量，允许该哲学家继续执行。

##### 优点

1. **避免死锁**：
   - 通过 **状态机** 控制哲学家的行为，避免了所有哲学家同时拿起左筷子、然后等待右筷子导致的循环等待。
   - 每个哲学家在状态为 **HUNGRY** 时会检测左邻居和右邻居是否可以吃饭。如果任一邻居正在吃饭，哲学家就会阻塞（通过 `down(&s[i])`）。
   - 只有当哲学家左右两边都没有人吃饭时，才允许哲学家开始吃饭。
2. **避免饥饿**：
   - 每个哲学家会根据 **`test()`** 函数的规则不断尝试吃饭。如果一个哲学家周围的邻居没有筷子，哲学家就会获得筷子并开始吃饭。
   - 这个策略确保了每个哲学家都会有机会吃饭，只要其他哲学家不长期占用两根筷子。
3. **公平性**：
   - 该解决方案具有某种程度的公平性，因为哲学家在 **HUNGRY** 状态时会不断尝试，而不会无限等待某一根筷子。
   - 因为信号量的机制，哲学家会被合理地唤醒（`up(&s[i])`），而不是无限阻塞在 **HUNGRY** 状态。

##### 实现

```c
#define N 5                  // 哲学家数量
#define LEFT (i + N - 1) % N // 左边哲学家(叉子)
#define RIGHT (i + 1) % N    // 右边哲学家(叉子)
#define THINKING 0
#define HUNGRY 1
#define EATING 2
typedef int semaphore;
int state[N];
semaphore mutex = 1;
semaphore s[N]; //每个哲学家的信号量,当哲学家获得两根筷子时，它会被释放（up(&s[i])），哲学家就可以继续执行

void philosopher(int i) // i:哲学家编号 from 0 to 4
{
    while (TRUE)
    {
        think();

        take_fork(i); // 获取到左右两边的叉子或者阻塞
        eat();
        put_fork(i); // 放回叉子到桌子上
    }
}

void take_fork(int i)
{
    down(&mutex); // 进入临界区
    state[i] = HUNGRY;
    test(i);    // 尝试拿起两个叉子
    up(&mutex); // 退出临界区
    down(&s[i]);
}
void put_fork(i)
{
    down(&mutex);
    state[i] = THINKING;
    test(LEFT);
    test(RIGHT);
    up(&mutex);
}

void test(i)
{
    if (state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] != EATING)
    {
        state[i] = EATING;
        up(&s[i]);
    }
}
```

### 读者-写者问题

> 在这个问题中，多个线程或进程需要访问一个共享的资源（通常是数据或文件），其中有两类操作：读取操作和写入操作。
>
> 问题的目标是设计一个机制，确保：
>
> - 读者可以并行读取共享资源；
> - 写者在访问共享资源时，其他读者和写者都不能同时访问该资源；
> - 保证系统的公平性和效率，避免死锁或饥饿现象。

#### 解决方案-读者优先策略

```c
typedef int semaphore;
semaphore mutex = 1;
semaphore db = 1;  //用于控制对数据库的访问。只有一个写者能够访问数据库，且当有写者在写数据时，读者和其他写者都无法访问数据库。
int rc = 0;  //读者计数
void reader(void)
{
    while (TRUE)
    {
        down(&mutex);
        rc = rc + 1;
        if (rc == 1)
            down(&db);
        up(&mutex);
        read_data_base(); //读取数据
        down(&mutex);
        rc = rc - 1;
        if (rc==0)
            up(&db);
        up(&mutex);
        use_data_read(); //处理读取到的数据
    }
}
void writer(void){
    while (TRUE)
    {
        think_up_data(); //写者的数据准备过程
        down(&db);
        write_data_base();
        up(&db);
    }
    
}
```

##### 为什么是读者优先？

- **读者的并发性**：多个读者可以并发访问数据库，只要没有写者在写入。每个读者进入临界区时会增加 `rc`，并且只有当第一个读者进入时，它才会阻止写者。只要有读者存在，写者必须等待。
- **写者的独占性**：当有写者准备写数据时，它必须等待所有读者结束阅读（即 `rc == 0`）后才能获得访问权限。这意味着写者的访问优先级是低于读者的。

### 理发师睡觉问题

> 假设理发店有一个理发师和若干个顾客，每个顾客都会先排队等待，直到理发师有空。如果没有顾客，理发师会睡觉；当有顾客到来时，理发师会醒来并为顾客理发。如果所有的座位都被占满（即已有顾客在排队），新的顾客就会离开，而不会等候。
>
> 具体来说，问题包括以下几个方面：
>
> 1. **理发师睡觉**：当没有顾客时，理发师就会进入“睡觉”状态。
> 2. **顾客到来**：顾客会在理发店等待，直到理发师可以为他们理发。如果理发店没有空座位（所有座位都被占用），顾客将离开。
> 3. **理发师为顾客理发**：当有顾客时，理发师会唤醒并为顾客提供理发服务。每个理发服务有一个固定的时间，理发师只能同时为一个顾客服务。

```c
#define CHAIRS 5
typedef int semaphore;
semaphore customers = 0;
semaphore barbers = 0;
semaphore mutex = 1;
int waiting = 0; //正在等待的顾客数量
void barber(void){
    while (TRUE)
    {
        down(&customers);
        down(&mutex);
        waiting = waiting - 1;
        up(&barbers);
        up(&mutex);
        cut_hair();
    }
}
void customer(void){
    down(&mutex);
    if (waiting < CHAIRS)
    {
        waiting = waiting + 1;
        up(&customers);
        up(&mutex);
        down(&barbers);4
        get_haircut();
    }else{
        up(&mutex);
    }
    
}
```

## 进程调度

* 作业调度（高级调度）

  当作业输入提交后，处于后备状态，该层调度以一定 的策略选择作业由输入设备进入内存，作业由后备态变为 运行态（在内存中的状态）

* 交换调度（中级调度）： 当进程在内存阻塞等待时，考虑提升内存利用率，按照一定策略选择进程将其交换至外存等待。 

* 进程调度（低级调度）： 按照一定策略选择获得CPU的进程，进程由绪态到运 行态

### 进程及作业调度的性能评价指标

#### 平均周转时间

Ｔi＝tie-tis   （ tie：作业完成时刻，tis：作业提交时刻） 

Ｔi＝tie-tir   （ tie：进程完成本次CPU周期时刻 tir：进程进入就绪队列时刻） 

![image-20241212103104320](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241212103104320.png)

#### 平均带权周转时间

 设 ti表示进程或作业的实际运行时间，则有

![image-20241212103200430](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241212103200430.png)

#### 平均等待时间：（主要针对进程而言）

![image-20241212103526828](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241212103526828.png)

### 调度算法

#### 先来先服务算法（FCFS)

> 特点：对执行时间短的进程及作业等待时间将长

##### eg1

假设有四道作业，它们的提交时刻及执行时间如下表： 

| 作业号 | 提交时刻 | 执行时间 |
| ------ | -------- | -------- |
| 1      | 8.00     | 2.00     |
| 2      | 8.50     | 0.50     |
| 3      | 9.00     | 0.10     |
| 4      | 9.50     | 0.20     |

分别求调度序列，平均周转时间及平均带权周转时间

![image-20241212105140862](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241212105140862.png)

##### eg2

有三个进程p1,p2,p3的本次cpu周期时值分别为21ms,6ms,3ms, 进程进入就绪队列的次序为p1,p2,p3

求调度序列，平均周转时间、平均带权周转时间、平均等待时间

![image-20241212110221968](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241212110221968.png)



#### 最短作业优先法（ＳＪＦ）

> 特点：
>
> * 吞吐量大 
> * 对不断有作业进入的系统，长作业将永得不到执行

选择估计需要执行时间最短的作业或进程投入运行（对进程而言，指估算的本次cpu周期的长短，如果是可剥夺式调度，则 按剩余最短原则）

##### eg1

假设有四道作业，它们的提交时刻及执行时间如下表： 

| 作业号 | 提交时刻 | 执行时间 |
| ------ | -------- | -------- |
| 1      | 8.00     | 2.00     |
| 2      | 8.50     | 0.50     |
| 3      | 9.00     | 0.10     |
| 4      | 9.50     | 0.20     |

分别求调度序列，平均周转时间及平均带权周转时间

![image-20241212112559886](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241212112559886.png)

#### 响应比高优先算法（ＨＲＮ）

> 特点:
>
> * 介于ＦＣＦＳ与ＳＪＦ之间 
> * 吞吐量减少
> *  增加了系统开销

响应比的计算方式如下：

![image-20241212114142817](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241212114142817.png)

其中：

- T 是进程的预计执行时间。

- W 是进程等待的时间，即从进程到达就绪队列到当前时间的时间。

- > 响应比的含义：
  >
  > - 当进程的等待时间 W很大时，响应比也会较高。
  > - 如果进程的预计执行时间 T较小，那么响应比也会较高。
  >
  > 因此，响应比高的进程将优先执行，确保那些长时间等待的进程能够得到更好的调度，避免它们一直被短进程抢占资源。

##### eg1

假设有四道作业，它们的提交时刻及执行时间如下表： 

| 作业号 | 提交时刻 | 执行时间 |
| ------ | -------- | -------- |
| 1      | 8.00     | 2.00     |
| 2      | 8.50     | 0.50     |
| 3      | 9.00     | 0.10     |
| 4      | 9.50     | 0.20     |

分别求调度序列，平均周转时间及平均带权周转时间

![image-20241213140050270](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241213140050270.png)

#### 轮转法（ＲＲ）

> 将ＣＰＵ时间划分成一个个时间片，每个进程轮流使用一个时间片
>
> 特点：时间片的设置： q=T/N      
>
> * T:  系统的最大响应时间 ＣＰＵ 
>
> * N:就绪队列中所允许的最大进程数
>
> * q 的取值不能过大或过小

有三个进程p1,p2,p3的本次cpu周期时值分别为21ms,6ms,3ms, 进程进入就绪队列的次序为p1,p2,p3

求调度序列，平均周转时间、平均带权周转时间、平均等待时间



#### 优先级调度算法

> 选择优先级高的进程／作业执行

##### eg1

有５个进程Ｐ１，Ｐ２，Ｐ３，Ｐ４，Ｐ５，它们的ＣＰＵ周期时值及优先级如下表：

|      | ＣＰＵ周期性 | 优先数 | 进入时刻 |
| ---- | ------------ | ------ | -------- |
| P1   | 32           | 5      | 0        |
| P2   | 4            | 3      | 0        |
| P3   | 8            | 2      | 0        |
| P4   | 2            | 6      | 0        |
| P5   | 16           | 4      | 16       |

1. 在非剥夺方式下，求它们的调度序列，平均等待时间，平均周转时间，平均带权周转时间(由2知优先级小的先执行)





2. 在可剥夺方式下，设优先级按如下规律变化：连续执行10ms以上后优先数 加１，就绪队列中的进程每40ms优先数减１；则求它们的调度序列，平均等待 时间，平均周转时间，平均带权周转时间

![image-20241215112451183](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241215112451183.png)

#### 多队列轮转法

> 进程按不同的优先级进入不同的队列，每个队列又采用不同的 算法

![image-20241213143246702](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241213143246702.png)
