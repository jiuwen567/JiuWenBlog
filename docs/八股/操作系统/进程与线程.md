## 并发vs并行

并发：两个或多个事件在同一个**时间间隔**之内同时发生

并行：两个或多个事件在**同一个时刻**同时发生

## 进程VS程序

* 进程是动态的，而程序是静态的 
* 进程可以并发，而程序则没有 
* 进程是资源竞争的基本单位

联系：一个程序可以生成多个不同的进程

## 进程

### 进程的层次结构

* 系统中除根进程外，每个进程都有且只有一个父进程
* 每个子进程均由它的父进程创建 
* 一个父进程可以有多个子进程

### 进程创建原因

* 系统初始化
* 正在执行的进程调用创建进程的系统调用
* 用户请求创建一个进程 
* 批处理作业的初始化

### 进程的终止

* 正常退出(voluntary) 
* 出错退出(voluntary) 
* 严重错误(involuntary) 
* 被其他进程杀死(involuntary)

### 守护进程

> Daemons（守护进程）--Processes that stay in the  background to handle some activity such as  email, Web pages, news,printing,and son on are  called daemons.

### 进程实现（静态描述）

#### 进程控制块ＰＣＢ

* 用来标识进程存在 于系统中的唯一的实体，部分或全部常驻内存

* 系统用ＰＣＢ反映进程的动态特征， 

  内容包括： 

  * 描述信息：进程名（标识号），用户名（标识号），家族链 
  * 控制信息：状态，优先级，内存始址，计时，通信信息 
  * 资源管理信息：内存、设备等信息 ．ＣＰＵ现场保护机构：寄存器

##### 主要字段

**![image-20241205180143343](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241205180143343.png)**

### 进程状态及其转换

* 运行态：正在使用CPU 
* 就绪态：可运行，指获取了除CPU之外的所有资源的进程状态。 
* 阻塞态：不可运行，且只能由其他外部事件发生而唤醒的状态

![image-20241205180650873](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241205180650873.png)

### 进程控制

系统使用具有特定功能的程序段来创建，撤消进程及完成进程之间状态转换

#### 原语

> a  single ,  indivisible  atomic  action （系统态下执行的某些具有特定功能的程序段） 

* 机器指令级：不允许中断 
* 功能级：不允许并发执行

#####  用于进程控制的原语

创建原语，撤消原语，阻塞原语，唤醒原语

## 线程

线程是轻量级的进程，它是一个进程内的基本调度单位，有自己的程序计数器、寄存器及堆栈。

### 多线程与多进程

* 多线程系统允许多个线程共享一个进程的地址空间、打开文件、全局变量等资源。

* 多进程系统允许多个进程共享物理内存、磁盘、打印机等资源。

### 线程与进程

* 进程是资源管理的基本单位

* 线程是调度的基本单位

### 引入线程的原因

* 伪并行，进一步提高并发度 
*  更小的系统开销 
*  更高的性能 
* 有利于在多CPU系统中实现真正的并行

## 进程通信

### 并发执行的进程间相互制约关系

* 间接制约：诸进程对共享资源的使用通过系统来协调，使得进程间执行速度相互影响。（进程间互斥）
* 直接制约：诸进程自行使用共享资源或由进程合作引起，某一进程直接通过某机制发消息给其他进程，从而直接影响其他进程的执行。（进程间同步）

### 基本概念

* 临界资源（竞争条件）：一次只允许一个进程使用的资源
* 临界区：在每个进程中，访问临界资源的那部分代码（那段程序）

### 进程通信方式

* 低级通信：同步&互斥

* 高级通信：管道通信、消息队列、共享内存、网络通信

## 互斥

> 不允许两个以上的共享该资源的并发进程同时进入临界区，称为互斥

### 并发进程互斥执行准则

* 不假设各并发进程的相对执行速度 
* 出于临界区外的进程不能阻止其他进程进入临界区 
* 任何时刻只允许一个进程处于临界区中 
* 不能使进程在临界区外永远等待

### 互斥的实现

1. 关中断法：每个进程进入临界区后先关中断，离开前开中断

* 缺点：系统可能终止 ．多CPU时，无用 

2. 加锁法：用锁变量来表示临界区是否可用

* 加锁后的临界区描述如下： 

```
lock(key[s]) 
<临界区>  
unlock(key[s])    //s为临界区类名 //key[s]为锁变量，为1表示临界区 //可用，为0表示临界区不能使用
```

* eg: 

  ```c
  lock(key[s])
  {
  L:
      if key[s] = 0 
      then goto L 
      else key[s] = 0
  }
  
  unlock(key[s]){
      key[s] = 1
  } 
  
  PA(){
      L1 : lock(key[s]) < s >
      unlock(key[s]) goto L1
  }
  
  PB()
  {
  L2:
      lock(key[s])<s>
      unlock(key[s]) goto L2
  }
  ```

* 缺点：

  * 不断循环测试，CPU费时 
  * 存在不公平现象

3. 严格的轮转法：用标志严格控制轮流使用临界区

   ```c
   PA()
    {
       
    while(true) {
        
    while(turn!=0);   //wait
    critical_region();
    turn=1;
    noncritical_region();
        
    }
    
    }
    
    PB()
    {
        
    while(true) {
        
    while(turn!=1);   //wait
    critical_region();
    turn=0;
    noncritical_region();
        
    }
        
    }
   ```

* 缺点：当一个进程比另一进程慢很多时不好

4. Peterson解决方案

   ```c
   #define False 0
   #define True 1
   #define N 2 // 两个进程
   
   int turn;
   int interested[N]; // 谁想进入临界区，对应位置置为1
   
   void enter_region(int process)
   {
       int other;
       other = 1 - process;
       interested[process] = True; // 该进程想要申请得到资源
       turn = process;             // 倾向于该进程
       while (turn == process && interested[other] == True);//其他进程想要进入时阻塞
   }
   void leave_region(int process){
       interested[process] = False;
   }
   ```

   * `turn` 的作用是保证两个进程在同时请求进入临界区时能按照顺序依次进入，从而避免死锁和饥饿，确保系统的公平性。

5. 信号量法

   * 信号量：是ＯＳ中表示资源的物理实体，是一个与队列相关的 整型变量，其值仅由down，up原语改变

   * 信号量的表示意义： 设s为信号量，则： 

     * 当s>=0时，表示可供并发进程使用的资源实体数 

     * 当s < 0时，表示正在等待使用资源的进程数

   * Ｐ、Ｖ原语的操作等同down、up原语操作

   * 信号量实现互斥

     ```c
     //设一个互斥的信号量sem
     //描述：S为临界区的类名
     ＰA：
     …
     down(sem)
      <S> 
     up(sem)
      …
     ＰB：
     …
     down(sem)
      <S> 
     up(sem)
     ```

## 管程

* 一种更为高级的同步原语，更便于使用，管程的互斥由编译 器负责，使用者只需将所有临界区转换为管程即可。 
* 一个管程是由过程、条件变量及数据结构等组成的特殊模块 或软件包。进程仅能通过管程访问其中的数据结构。 
* 管程的特性：任一时刻管程中只能有一个活跃进程

## 进程同步

>  异步环境下，一组并发进程因直接制约而相互发送消息， 相互合作，相互等待，使各进程按一定速度执行的过程

### 同步的实现

1. 消息名法

   > 为同步进程间发送的事件或消息赋予一个唯一的消息名，
   >
   > 用：
   >
   > wait（）表示进程等待合作进程发来的消息)
   >
   > signal（）表示向合作进程发送消息

   描述：

   * ```c
     //设消息名Bufempty表示Buf为空，Buffull表示Buf满
     //初始化：Bufempty=true,  Buffull=false
     
     Pc:
     A:    
     wait(Bufempty)
     caculate
     buf <- result
     Bufempty <- false
     signal(Buffull)
     Goto  A
        
     Pp:
     B:    
     wait(Buffull)
     print 
     buf <- null
     Buffull <- false
     signal(Bufempty)
     Goto  B
     ```

2. 信号量法

   ```c
   //SA表示进程Pc的资源信号量，即buf为空，可放数据，初始化为SA=1；
   //SB表示buf中有数据，初始化为SB=0；
   
   Pc:
    A:  caculate  next  number
    buf <- result 
   count=count-1 
   V(SB)
    P(SA)
    if  
   count=0  then  destroy(Pc) 
   else  goto  A
       
   Pp:
    B:    P(SB)
    print <- buf
    V(SA)
    print the last number
    if  count=0  then 
   destroy(Pp)
    else  goto  B
   
   ```

## 进程高级通信

> 消息传递 
>
> 1. 引入:
>
> * 信号量需要编程语言支持.
>
> *  信号量在网络环境下不可用 •
>
> 2. 实现: 
>
> * send(destination, &message) 
> * receive(source, &message)

### 用N条消息实现的生产者-消费者问题

```c
#define N 100

void producer(){
    int item;
    message m;
    while (TRUE)
    {
        item = produce_item(); // 生成一个商品
        receive(consumer, &m); // 从消费者接收消息（消费者可能发送一个空的消息，表示消费者准备好接收新的商品）
        build_message(&m,item);  // 使用生成的商品构建消息
        send(consumer, &m); //发送消息给消费者
    }
    
}

void consumer(){
    int item;
    message m;
    for (int i = 0; i < N; i++)
    {
        send(producer,&m) // 向生产者发送初始消息，可能是空消息，表示消费者准备好了
    }
    
    while (TRUE)
    {
        receive(producer, &m); // 从生产者接收商品消息
        item = extract_item(&m); // 从消息中提取商品
        send(producer,&m); // 消费者发送消息给生产者，可能表示消费者可以继续消费
        consume_item(item);   //消费商品
    }

}
```

### 生产者-消费者问题

```c
#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer()
{
    int item;
    while (TRUE)
    {
        item = produce_item();
        down(&empty);
        down(&mutex); //进入临界区
        insert_item(item); //放入数据到缓冲区
        up(&mutex); // 离开临界区
        up(&full);
    }
}

void consumer()
{
    int item;
    while (TRUE)
    {
        down(&full);
        down(&mutex); //进入临界区
        item = remove_item(); //从缓冲区取数据
        up(&mutex); // 离开临界区
        up(&empty);
        consume_item(item) //消费商品
    }
}
```

### 哲学家就餐问题

> **哲学家就餐问题**是经典的并发与同步问题，通常用来描述多个进程如何共享资源的情景。在这个问题中，哲学家们坐在餐桌旁，他们的任务是思考、拿起两根筷子（共享资源），然后吃饭。哲学家们必须交替进行思考、吃饭、和放下筷子(叉子)。然而，如果哲学家们不遵循适当的规则，就会出现以下几种问题：
>
> 1. **死锁（Deadlock）**：所有的哲学家都拿着一根筷子并且等待另一根筷子，这样他们就都无法继续吃饭。
> 2. **饥饿（Starvation）**：某些哲学家永远不能获得足够的筷子来吃饭，而是被其他哲学家不断抢占。
> 3. **竞态条件（Race Condition）**：不同哲学家对共享资源的访问会出现冲突，导致不一致的状态。

#### 问题描述

![image-20241208115728710](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241208115728710.png)

- **资源**：每个哲学家有两根筷子（叉子），坐在圆桌旁。

- 任务

  ：每个哲学家反复进行以下操作：

  - 思考（Think）
  - 拿起两根筷子（Pick up both chopsticks）
  - 吃饭（Eat）
  - 放下筷子（Put down both chopsticks）

- **条件**：每根筷子是共享的，任何两位哲学家不能同时使用同一根筷子。

#### 错误的做法

```c
#define N 5  //哲学家数量

void philosopher(int i) //i:哲学家编号 from 0 to 4
{
    while (TRUE)
    {
        think();
        //拿左右两边的筷子
        take_fork(i);
        take_fork((i+1)%N);
        eat();
        put_fork(i);
        put_fork((i+1)%N);
    }
}

```

两个哲学家同时试图拿起两根筷子时，死锁会发生!!

##### 死锁的产生：

死锁发生的条件是**循环等待**，即一组进程在等待资源时，形成一个环路。具体来说：

1. 假设所有哲学家同时开始尝试拿筷子。
2. 哲学家 `0` 先拿起了 **左边的筷子 `fork[0]`**。
3. 然后，哲学家 `1` 也拿起了 **左边的筷子 `fork[1]`**，哲学家 `2` 拿起了 **左边的筷子 `fork[2]`**，依此类推。
4. 然后，哲学家们开始尝试拿右边的筷子：
   - 哲学家 `0` 尝试拿 **右边的筷子 `fork[1]`**（被哲学家 `1` 拿走了）。
   - 哲学家 `1` 尝试拿 **右边的筷子 `fork[2]`**（被哲学家 `2` 拿走了）。
   - 以此类推，直到哲学家 `4` 尝试拿 **右边的筷子 `fork[0]`**（被哲学家 `0` 拿走了）。

##### 形成循环等待：

此时，所有哲学家都已经拿到了 **一根筷子**，但每个哲学家都在等待**另一根筷子**。具体来说：

- 哲学家 `0` 拿了 `fork[0]`，但在等待 `fork[1]`。
- 哲学家 `1` 拿了 `fork[1]`，但在等待 `fork[2]`。
- 哲学家 `2` 拿了 `fork[2]`，但在等待 `fork[3]`。
- 哲学家 `3` 拿了 `fork[3]`，但在等待 `fork[4]`。
- 哲学家 `4` 拿了 `fork[4]`，但在等待 `fork[0]`。

> ##### **死锁发生的条件**：
>
> 死锁的经典条件通常包括以下四个条件（叫做 **死锁的必要条件**）：
>
> 1. **互斥条件**：每个资源（这里是筷子）只能被一个哲学家使用。
> 2. **占用并等待条件**：哲学家已经占用了一个筷子，并等待获取另一个筷子。
> 3. **不剥夺条件**：已经获取的筷子不能被强制剥夺，只有哲学家自己放下筷子。
> 4. **循环等待条件**：存在一个哲学家等待另外一个哲学家的筷子，形成一个环路。

#### 解决方案1

>  让 **偶数编号的哲学家** 先拿 **左筷子**，然后再拿 **右筷子**；而 **奇数编号的哲学家** 先拿 **右筷子**，再拿 **左筷子**。这样可以避免所有哲学家同时拿起一根筷子并阻塞，从而避免死锁。

实现：

```c
#define N 5  // 哲学家数量

void philosopher(int i) //i:哲学家编号 from 0 to 4
{
    while (TRUE)
    {
        think();
        
        // 偶数编号哲学家先拿左筷子，再拿右筷子
        if (i % 2 == 0) {
            take_fork(i);
            take_fork((i + 1) % N);
        }
        // 奇数编号哲学家先拿右筷子，再拿左筷子
        else {
            take_fork((i + 1) % N);
            take_fork(i);
        }
        
        eat();
        put_fork(i);
        put_fork((i + 1) % N);
    }
}

```

#### 解决方案2-资源分配策略

> 使用了 **信号量（semaphore）** 和 **进程状态管理** 来避免死锁和饥饿问题。它属于 **使用条件变量和互斥锁的同步解决方案**，是一种基于 **状态机** 的解决方案

##### 1. **状态管理**

每个哲学家都有 3 种状态：

- **THINKING**：哲学家正在思考，不需要任何筷子。
- **HUNGRY**：哲学家正在等待筷子（已经准备好吃饭）。
- **EATING**：哲学家正在吃饭，正在使用两根筷子。

##### 2. **信号量**

- **`mutex`**：用于保护对共享资源（`state[]` 数组）的访问，确保在修改状态时互斥。
- **`s[i]`**：是每个哲学家的信号量。每个哲学家的 `s[i]` 信号量控制哲学家的进程何时能继续执行（即什么时候能开始吃饭）。它的作用是当哲学家获得两根筷子时，它会被释放（`up(&s[i])`），哲学家就可以继续执行。

##### 3. **`take_fork(i)`**：尝试拿起左右两边的筷子

- **进入临界区**：通过 `down(&mutex)`，保护 `state[i]` 的修改。
- **更改状态为 HUNGRY**：哲学家将自己的状态设置为 **HUNGRY**，表示他想吃饭了。
- **尝试吃饭**：调用 `test(i)` 来检查该哲学家是否能够拿起两根筷子。
- **退出临界区**：通过 `up(&mutex)`，释放互斥锁。
- **阻塞自己**：如果哲学家不能同时拿到两根筷子（即左右两边的哲学家正在吃饭），则阻塞自己，等待 `s[i]` 信号量。

##### 4. **`put_fork(i)`**：放下两根筷子

- **进入临界区**：同样使用 `down(&mutex)` 来保护对 `state[]` 数组的修改。
- **更改状态为 THINKING**：哲学家吃完饭后，将自己的状态设置为 **THINKING**。
- **检查左、右邻居**：调用 `test(LEFT)` 和 `test(RIGHT)` 来检查左邻居和右邻居是否能够开始吃饭。如果他们处于 **HUNGRY** 状态并且没有在吃饭，那么就可以让他们开始吃饭。
- **退出临界区**：通过 `up(&mutex)` 来释放互斥锁。

##### 5. **`test(i)`**：判断哲学家是否可以吃饭

- **检查条件**：只有当哲学家处于 **HUNGRY** 状态，且左边和右边的哲学家都没有在吃饭时（`state[LEFT] != EATING && state[RIGHT] != EATING`），该哲学家才能开始吃饭。
- **更新状态**：如果条件满足，则将哲学家的状态改为 **EATING**，并通过 `up(&s[i])` 释放哲学家的信号量，允许该哲学家继续执行。

##### 优点

1. **避免死锁**：
   - 通过 **状态机** 控制哲学家的行为，避免了所有哲学家同时拿起左筷子、然后等待右筷子导致的循环等待。
   - 每个哲学家在状态为 **HUNGRY** 时会检测左邻居和右邻居是否可以吃饭。如果任一邻居正在吃饭，哲学家就会阻塞（通过 `down(&s[i])`）。
   - 只有当哲学家左右两边都没有人吃饭时，才允许哲学家开始吃饭。
2. **避免饥饿**：
   - 每个哲学家会根据 **`test()`** 函数的规则不断尝试吃饭。如果一个哲学家周围的邻居没有筷子，哲学家就会获得筷子并开始吃饭。
   - 这个策略确保了每个哲学家都会有机会吃饭，只要其他哲学家不长期占用两根筷子。
3. **公平性**：
   - 该解决方案具有某种程度的公平性，因为哲学家在 **HUNGRY** 状态时会不断尝试，而不会无限等待某一根筷子。
   - 因为信号量的机制，哲学家会被合理地唤醒（`up(&s[i])`），而不是无限阻塞在 **HUNGRY** 状态。

##### 实现

```c
#define N 5                  // 哲学家数量
#define LEFT (i + N - 1) % N // 左边哲学家(叉子)
#define RIGHT (i + 1) % N    // 右边哲学家(叉子)
#define THINKING 0
#define HUNGRY 1
#define EATING 2
typedef int semaphore;
int state[N];
semaphore mutex = 1;
semaphore s[N]; //每个哲学家的信号量,当哲学家获得两根筷子时，它会被释放（up(&s[i])），哲学家就可以继续执行

void philosopher(int i) // i:哲学家编号 from 0 to 4
{
    while (TRUE)
    {
        think();

        take_fork(i); // 获取到左右两边的叉子或者阻塞
        eat();
        put_fork(i); // 放回叉子到桌子上
    }
}

void take_fork(int i)
{
    down(&mutex); // 进入临界区
    state[i] = HUNGRY;
    test(i);    // 尝试拿起两个叉子
    up(&mutex); // 退出临界区
    down(&s[i]);
}
void put_fork(i)
{
    down(&mutex);
    state[i] = THINKING;
    test(LEFT);
    test(RIGHT);
    up(&mutex);
}

void test(i)
{
    if (state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] != EATING)
    {
        state[i] = EATING;
        up(&s[i]);
    }
}
```

### 读者-写者问题

> 在这个问题中，多个线程或进程需要访问一个共享的资源（通常是数据或文件），其中有两类操作：读取操作和写入操作。
>
> 问题的目标是设计一个机制，确保：
>
> - 读者可以并行读取共享资源；
> - 写者在访问共享资源时，其他读者和写者都不能同时访问该资源；
> - 保证系统的公平性和效率，避免死锁或饥饿现象。

#### 解决方案-读者优先策略

```c
typedef int semaphore;
semaphore mutex = 1;
semaphore db = 1;  //用于控制对数据库的访问。只有一个写者能够访问数据库，且当有写者在写数据时，读者和其他写者都无法访问数据库。
int rc = 0;  //读者计数
void reader(void)
{
    while (TRUE)
    {
        down(&mutex);
        rc = rc + 1;
        if (rc == 1)
            down(&db);
        up(&mutex);
        read_data_base(); //读取数据
        down(&mutex);
        rc = rc - 1;
        if (rc==0)
            up(&db);
        up(&mutex);
        use_data_read(); //处理读取到的数据
    }
}
void writer(void){
    while (TRUE)
    {
        think_up_data(); //写者的数据准备过程
        down(&db);
        write_data_base();
        up(&db);
    }
    
}
```

##### 为什么是读者优先？

- **读者的并发性**：多个读者可以并发访问数据库，只要没有写者在写入。每个读者进入临界区时会增加 `rc`，并且只有当第一个读者进入时，它才会阻止写者。只要有读者存在，写者必须等待。
- **写者的独占性**：当有写者准备写数据时，它必须等待所有读者结束阅读（即 `rc == 0`）后才能获得访问权限。这意味着写者的访问优先级是低于读者的。

### 理发师睡觉问题

> 假设理发店有一个理发师和若干个顾客，每个顾客都会先排队等待，直到理发师有空。如果没有顾客，理发师会睡觉；当有顾客到来时，理发师会醒来并为顾客理发。如果所有的座位都被占满（即已有顾客在排队），新的顾客就会离开，而不会等候。
>
> 具体来说，问题包括以下几个方面：
>
> 1. **理发师睡觉**：当没有顾客时，理发师就会进入“睡觉”状态。
> 2. **顾客到来**：顾客会在理发店等待，直到理发师可以为他们理发。如果理发店没有空座位（所有座位都被占用），顾客将离开。
> 3. **理发师为顾客理发**：当有顾客时，理发师会唤醒并为顾客提供理发服务。每个理发服务有一个固定的时间，理发师只能同时为一个顾客服务。

```c
#define CHAIRS 5
typedef int semaphore;
semaphore customers = 0;
semaphore barbers = 0;
semaphore mutex = 1;
int waiting = 0; //正在等待的顾客数量
void barber(void){
    while (TRUE)
    {
        down(&customers);
        down(&mutex);
        waiting = waiting - 1;
        up(&barbers);
        up(&mutex);
        cut_hair();
    }
}
void customer(void){
    down(&mutex);
    if (waiting < CHAIRS)
    {
        waiting = waiting + 1;
        up(&customers);
        up(&mutex);
        down(&barbers);4
        get_haircut();
    }else{
        up(&mutex);
    }
    
}
```

## 进程调度

* 作业调度（高级调度）

  当作业输入提交后，处于后备状态，该层调度以一定 的策略选择作业由输入设备进入内存，作业由后备态变为 运行态（在内存中的状态）

* 交换调度（中级调度）： 当进程在内存阻塞等待时，考虑提升内存利用率，按照一定策略选择进程将其交换至外存等待。 

* 进程调度（低级调度）： 按照一定策略选择获得CPU的进程，进程由绪态到运 行态

### 进程及作业调度的性能评价指标

#### 平均周转时间

Ｔi＝tie-tis   （ tie：作业完成时刻，tis：作业提交时刻） 

Ｔi＝tie-tir   （ tie：进程完成本次CPU周期时刻 tir：进程进入就绪队列时刻） 

![image-20241212103104320](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241212103104320.png)

#### 平均带权周转时间

 设 ti表示进程或作业的实际运行时间，则有

![image-20241212103200430](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241212103200430.png)

#### 平均等待时间：（主要针对进程而言）

![image-20241212103526828](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241212103526828.png)

### 调度算法

#### 先来先服务算法（FCFS)

> 特点：对执行时间短的进程及作业等待时间将长

##### eg1

假设有四道作业，它们的提交时刻及执行时间如下表： 

| 作业号 | 提交时刻 | 执行时间 |
| ------ | -------- | -------- |
| 1      | 8.00     | 2.00     |
| 2      | 8.50     | 0.50     |
| 3      | 9.00     | 0.10     |
| 4      | 9.50     | 0.20     |

分别求调度序列，平均周转时间及平均带权周转时间

![image-20241212105140862](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241212105140862.png)

##### eg2

有三个进程p1,p2,p3的本次cpu周期时值分别为21ms,6ms,3ms, 进程进入就绪队列的次序为p1,p2,p3

求调度序列，平均周转时间、平均带权周转时间、平均等待时间

![image-20241212110221968](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241212110221968.png)



#### 最短作业优先法（ＳＪＦ）

> 特点：
>
> * 吞吐量大 
> * 对不断有作业进入的系统，长作业将永得不到执行

选择估计需要执行时间最短的作业或进程投入运行（对进程而言，指估算的本次cpu周期的长短，如果是可剥夺式调度，则 按剩余最短原则）

##### eg1

假设有四道作业，它们的提交时刻及执行时间如下表： 

| 作业号 | 提交时刻 | 执行时间 |
| ------ | -------- | -------- |
| 1      | 8.00     | 2.00     |
| 2      | 8.50     | 0.50     |
| 3      | 9.00     | 0.10     |
| 4      | 9.50     | 0.20     |

分别求调度序列，平均周转时间及平均带权周转时间

![image-20241212112559886](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241212112559886.png)

#### 响应比高优先算法（ＨＲＮ）

> 特点:
>
> * 介于ＦＣＦＳ与ＳＪＦ之间 
> * 吞吐量减少
> *  增加了系统开销

响应比的计算方式如下：

![image-20241212114142817](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241212114142817.png)

其中：

- T 是进程的预计执行时间。

- W 是进程等待的时间，即从进程到达就绪队列到当前时间的时间。

- > 响应比的含义：
  >
  > - 当进程的等待时间 W很大时，响应比也会较高。
  > - 如果进程的预计执行时间 T较小，那么响应比也会较高。
  >
  > 因此，响应比高的进程将优先执行，确保那些长时间等待的进程能够得到更好的调度，避免它们一直被短进程抢占资源。

##### eg1

假设有四道作业，它们的提交时刻及执行时间如下表： 

| 作业号 | 提交时刻 | 执行时间 |
| ------ | -------- | -------- |
| 1      | 8.00     | 2.00     |
| 2      | 8.50     | 0.50     |
| 3      | 9.00     | 0.10     |
| 4      | 9.50     | 0.20     |

分别求调度序列，平均周转时间及平均带权周转时间

![image-20241213140050270](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241213140050270.png)

#### 轮转法（ＲＲ）

> 将ＣＰＵ时间划分成一个个时间片，每个进程轮流使用一个时间片
>
> 特点：时间片的设置： q=T/N      
>
> * T:  系统的最大响应时间 ＣＰＵ 
>
> * N:就绪队列中所允许的最大进程数
>
> * q 的取值不能过大或过小

有三个进程p1,p2,p3的本次cpu周期时值分别为21ms,6ms,3ms, 进程进入就绪队列的次序为p1,p2,p3

求调度序列，平均周转时间、平均带权周转时间、平均等待时间



#### 优先级调度算法

> 选择优先级高的进程／作业执行

##### eg1

有５个进程Ｐ１，Ｐ２，Ｐ３，Ｐ４，Ｐ５，它们的ＣＰＵ周期时值及优先级如下表：

|      | ＣＰＵ周期性 | 优先数 | 进入时刻 |
| ---- | ------------ | ------ | -------- |
| P1   | 32           | 5      | 0        |
| P2   | 4            | 3      | 0        |
| P3   | 8            | 2      | 0        |
| P4   | 2            | 6      | 0        |
| P5   | 16           | 4      | 16       |

1. 在非剥夺方式下，求它们的调度序列，平均等待时间，平均周转时间，平均带权周转时间(由2知优先级小的先执行)

![image-20241216190550053](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241216190550053.png)

2. 在可剥夺方式下，设优先级按如下规律变化：连续执行10ms以上后优先数 加１，就绪队列中的进程每40ms优先数减１；则求它们的调度序列，平均等待 时间，平均周转时间，平均带权周转时间

![image-20241215112451183](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241215112451183.png)

#### 多队列轮转法

> 进程按不同的优先级进入不同的队列，每个队列又采用不同的 算法

![image-20241213143246702](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241213143246702.png)

## 思考题

1. **进程的定义**
   * 可以与其他程序并发执行的程序的一次执行，是系统资源分配的基本单位

2. **进程的特征**
   * 动态Dynamic（创建、调度执行、撤消） 
   * 并发Concurrency （多道并发）
   * 独立Independent（逻辑独立性） 
   * 异步Asynchronous（不假设进行何时开始、结束） 
   * 结构structure（逻辑结构）

3. 进程与程序的区别和联系
   * [区别与联系](#进程VS程序)

4. 进程实体的组成

   * 程序段
   * 数据段
   * 进程控制块（PCB）

5. PCB 的作用和特点
   * 反映进程的动态特征
   * 特点：

6. **进程的状态及其变迁（并能说出原因）**
   * [进程状态及其转换](#进程状态及其转换)

7. 处理机的执行状态（核心态、用户态）

8. 内核的定义及功能；**原语的定义及功能**
   * [原语定义](#原语)
   * 原语功能：创建，撤消进程及完成进程之间状态转换

9. 进程控制方式

10. **进程同步与互斥的定义**
    * 进程同步：异步环境下，一组并发进程因直接制约而相互发送消息， 相互合作，相互等待，使各进程按一定速度执行的过程
    * 互斥：不允许两个以上的共享该资源的并发进程同时进入临界区，称为互斥

11. **临界资源与临界区的定义**
    * 临界资源（竞争条件）：一次只允许一个进程使用的资源
    * 临界区：在每个进程中，访问临界资源的那部分代码（那段程序）

12. 好的互斥方案应遵循的条件
    * [条件](#并发进程互斥执行准则)

13. **信号量机机制P（down）V(up)操作的原理**

14. **PV 操作解决互斥**

15. **PV 操作解决于生产者与消费者问题** 

16. 进程通信的类型及其过程和特点
    * 低级通信：同步&互斥 
    * 高级通信：管道通信、消息队列、共享内存、网络通信

17. 进程调度的概念、方式、原因、过程

18. **进程调度的算法**
    * [调度算法](#调度算法)

19. 高级高度（作业调度）的算法

20. **线程的定义和作用；线程与进程的联系与区别、线程的类型**
    * [定义](#线程)
    * [作用](#引入线程的原因)
    * 区别：
      1. 进程是资源管理的基本单位，而线程是调度的基本单位。[参考](#线程与进程)
      2. 进程间切换开销大，线程间切换开销小
      3. 进程有独立的内存单元，线程共享进程内存。
    * 联系：
      1. 线程是进程的一部分，一个进程至少有一个线程（主线程）
      2. 进程是线程存在的前提。
      3. 线程是进程的基本执行单元，一个进程中的所有任务都在线程中执行

21. ![image-20250107122713862](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20250107122713862.png)
    * 分下面几种情况：
      1. P0、P1、P2都在1个CPU1个线程运行 （35ms）
      2. P0、P1在不同线程运行、P1和P2同一线程（30ms）
      3. P0、P1在不同线程运行、P0和P2同一线程（25ms）
      4. P0、P2在不同线程运行、P0和P1同一线程 (20ms)
      5. P0、P2在不同线程运行、P2和P1同一线程 (30ms)
      6. P1、P2在不同线程运行、P1和P0同一线程（20ms）
      7. P1、P2在不同线程运行、P2和P0同一线程（25ms）
      8. P1、P2、P3都再不同线程运行（20ms）

22. ![image-20250107132042846](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20250107132042846.png)

    * 设一个进程等待概率为x

      最大进程数为：(4096-512)/256=14

      进程都等待概率为：x^14^=1%

## 思考题2

1. 计算机系统内资源分配是以进程为单位还是线程为单位，为什么？
   * 资源分配通常是以进程为单位进行的。这是因为进程拥有独立的地址空间和资源集合，这样可以更好地隔离不同进程，提高系统的稳定性和安全性。线程作为进程的一部分，共享进程的资源，这样可以减少资源分配和管理的开销。
2. 请举例一个你所知道的多线程应用场景的例子。
   * 一个常见的多线程应用场景是Web服务器。Web服务器需要同时处理多个客户端的请求，每个请求可以由一个线程来处理。这样，服务器可以并行处理多个请求，提高响应速度和吞吐量。
3. 临界区访问机制的四个原则是什么。
   临界区访问机制通常遵循以下四个原则：
   * 忙则等待：当临界区正在被某个进程访问时（即忙状态），其他试图进入临界区的进程必须等待，直到临界区变为空闲状态。
   * 空闲让进：当临界区处于空闲状态时，允许一个请求进入临界区的进程立即进入临界区进行访问。
   * 有限等待：对要求访问临界区的进程，应保证其在有限时间内能够进入临界区，避免进程无限期地等待，从而陷入“死等”状态。
   * 让权等待：当进程不能进入临界区时，应当释放CPU，使其他进程有机会获得CPU，避免进程陷入“忙等”状态，浪费系统资源。
4. 进程具有异步性。异步，即每个程序不考虑其它程序的运行进度，按自己的逻辑往前运行。那么，异步性这个特点，好不好呢？是进程的优点还是缺点呢？
   * 异步性是进程的一个重要特性，它允许多个进程独立运行，互不干扰。这通常被认为是一个优点，因为它提高了系统的并发性和效率。然而，如果不正确地管理异步性，可能会导致竞态条件和死锁等问题，这时它可能成为缺点。因此，异步性本身是中性的，关键在于如何管理和控制。
5. 实际操作系统中，为何没有“阻塞到运行”或“就绪到阻塞”这样的状态迁移？
   * 在实际的操作系统中，状态迁移通常遵循一定的逻辑和顺序。一个进程从阻塞状态直接变为运行状态是不合理的，因为它需要先进入就绪状态，等待CPU调度。同样，一个进程从就绪状态直接变为阻塞状态也是不合理的，因为它需要先被调度运行。状态迁移需要遵循操作系统的调度策略和资源管理机制，以确保系统的稳定性和效率。
6. 进程可以通过什么来实现？在Linux操作系统下，通过哪个结构实现
   * 进程可以通过进程控制块PCB、程序、数据集实现。在Linux操作系统下，进程是通过“task_struct”结构和“thread_info”结构来实现的。
7. 进程调度的本质是什么？
   * 进程调度的本质是进程上下文切换
8. “撤销进程”的定义中提到，撤销一个进程之前，先【递归】检查其是否有子进程，如有，应先“撤销”子进程。请问，Linux是否会按这个要求去撤销某个进程?如果是的话，会有什么后果?如果不是的话，系统如何处理该进程的子孙进程（这些进程将失去父进程或祖先进程）？
   * Linux会按照先递归检查子进程再撤销父进程的要求去处理。如果一个进程有子进程，那么在该进程被撤销之前，系统会先递归地撤销其所有子进程。这样做是为了避免产生僵尸进程（即已终止但尚未被父进程回收的进程）。撤销进程后，系统会释放该进程所占用的资源，并将其从进程列表中移除。如果不按照这个要求去撤销进程，那么子进程可能会变成孤儿进程（即父进程已终止但子进程仍在运行的进程）。在Linux中，孤儿进程会被init进程（PID为1的进程）收养，并由init进程负责回收其资源。
9. 锁机制若是软件实现，会存在什么问题？
   * 如果锁机制是软件实现的，那么它可能会存在效率较低、容易受到系统其他部分影响的问题。因为软件锁需要通过操作系统提供的系统调用来实现，这会涉及到上下文切换、系统调用开销等额外成本。此外，软件锁还可能存在死锁、饥饿等并发编程中常见的问题。
10. 举出生活中类似“司机和售票员”的同步例子
    * 生活中类似“司机和售票员”的同步例子很多，比如厨师和服务员在餐厅中的工作配合。厨师负责烹饪食物，服务员负责将食物送到顾客手中。他们之间需要通过对讲喊话等方式来同步工作节奏，以确保食物能够及时、准确地送到顾客手中。
11. V操作定义中的q队列里面的进程都是阻塞进程。请问这些进程是从何而来的？或者说这些进程是怎么变成阻塞状态进入q队列的？ 
    * 在V操作中，q队列里面的进程都是因等待某种资源或事件而处于阻塞状态的进程。这些进程在请求资源或事件时，如果资源或事件不可用，它们就会被放入q队列中等待。当资源或事件变得可用时，系统会通过V操作来唤醒这些进程并继续执行。进程变成阻塞状态进入q队列的原因通常是因为它们需要等待I/O操作完成、等待信号量释放、等待互斥锁等。
12. 子进程的exit( )函数返回参数由父进程处理或接收。那么，在控制台上直接启动的一个应用程序，其末尾的exit( )函数返回参数由谁处理或接收？
    * 在控制台上直接启动的一个应用程序，其末尾的exit()函数返回参数通常由操作系统处理或接收。操作系统会根据这个返回参数来结束进程并释放相关资源。在某些情况下，这个返回参数也可以被其他进程（如父进程或监控进程）通过特定方式（如管道、信号等）来获取。
13. 进程调度的7个目标中，批处理系统、分时系统、实时系统分别更注重哪些目标？
    * 批处理系统更注重大的吞吐量、短的周转时间、高的CPU利用率；分时系统更注重均衡性和短的响应时间；实时系统更注重满足实时性要求和具有可预测性。
14. 各种调度算法各有优势，请你给出一个更优的调度算法的基本思想描述
    * 一个更优的调度算法应该能够综合考虑各种因素（如进程优先级、系统负载、资源使用情况等）来做出更合理的调度决策。其基本思想可以包括：根据进程优先级来分配处理器资源，以确保高优先级进程能够得到及时响应；通过动态调整进程优先级来平衡系统负载和资源使用情况；采用合适的上下文切换机制来减少调度开销等。
15.  Linux系统中普通进程采用何种调度策略？实时进程又采用何种调度策略？ 
    * 在Linux系统中，普通进程通常采用CFS（Completely Fair Scheduler）调度策略。CFS是一种基于虚拟运行时间（vruntime）的调度算法，它力求让所有进程在长期内获得大致相等的CPU时间份额。而对于实时进程来说，Linux提供了抢占式实时调度策略，包括SCHED_FIFO（先入先出）和SCHED_RR（时间片轮转）等。这些策略允许实时进程根据优先级和调度策略规则被优先调度执行。
