# 逻辑运算指令

## 求“反”指令NOT

`NOT  OPD`

* 功能：将目的地址中的内容逐位取反后送入目的地址

* NOT指令对状态标志位无影响。

* eg:

  ```assembly
   MOV AX，878AH    ;(AX)=878AH
   NOT AX   ;(AX)=7875H
  ```
  


## 逻辑“与”指令AND

`AND  OPD， OPS`

* 功能：将目的操作数和源操作数按位进行逻 辑“与”运算，结果存目的地址

* 状态标志位的影响：OF和CF清0

  * eg:

  * ```assembly
    某个操作数与本身进行“与”运算：
    AND AL，AL
    结果：操作数本身显然不变，经常用于将进位标志位CF清“0”。
    ```

* AND指令常常用于对目的操作数中的指定一位或多位清0

  * eg:

  * ```assembly
    分析指令功能：AND    AX，0FFH
    结果：AX高8位(AH)被清“0”，而AX低8位(AL)值不变。
    ```

## 逻辑或指令OR

`OR  OPD，OPS`

* 功能：目的操作数和源操作数进行逻辑 “或”运算，结果存目的地址，即 (OPD)∨(OPS)→OPD。

* 状态标志位的影响：OF和CF清0

* OR指令常常用于对目的操作数中的指定一位或多位 置1

  * eg:

  * ```assembly
    将AL寄存器中第3位和第7位置1。
    OR AL，88H
    ```

* 类似于AND指令，某个操作数与本身进行或运算：

  * ```assembly
    OR AX ，AX
    操作的结果是：操作数不变，但使CF清“0”。
    ```

## 异或XOR指令

`XOR  OPD，OPS`

* 功能：目的操作数与源操作数做按位异或运算，结 果送入目的地址，即：(OPD)⊕(OPS) →OPD。

* 状态标志位的影响：OF和CF清0

* 异或运算也可称为“按位加/减”

  * eg:将AL寄存器中第3位和第7位取反

  * ```assembly
    XOR AL， 88H
    ```

* 按位加运算

  * ```assembly
    MOV AL，45H ;(AL)=45H
    XOR AL，31H ;(AL)=74H
    ```

* 源、目不允许同为内存操作数。
* 当源为立即数，目为内存操作数时，须用 PTR说明目属性。

## 测试指令TEST

`TEST  OPD，OPS`

* 状态标志影响情况与AND、OR、XOR相同

  * CF、OF清0

* 影响ZF、SF、PF

* 该指令常与条件转移指令配合使用，以决定 程序的转移方向。

  * eg:测试AX中的第12位是否为0，如果为0则 跳转至NEXT。

  * ```assembly
    TEST  AX，1000H    ;0001 0000 0000 0000B
    JZ NEXT
    ```

## 位测试指令

1. 位测试：BT 目标，源操作数 
2. 位测试置0：BTR 目，源 
3. 位测试置1：BTS 目，源 
4. 位测试取反：BTC目，源

四条指令相同点：测试目中的由源指定的某一位， 并将测试位位值送C标志。若测试的位置大于目标操作数的长度，则取源/目的余数才是测试位。指令执行完后源不变。

不同：BT执行后，目不变；BTR，BTS，BTC 执行后对测试位做相应的操作：清0，置1，取反。

![image-20250103102617902](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20250103102617902.png)

* BT AX，0        ;AX的D0位→ C标 

* BT AX，16     ;AX的D0位→ C标志， 

* BTR EAX，31   ;EAX的D31位→ C标志，然 后EAX的D31置0       

  ```assembly
  MOV EAX，48
  BTS EBX，EAX   ;EBX的D16位→ C标志， 然后EBX的D16置1；EAX不变。(测试位 =EBX  MOD EAX=32 MOD 48=16)
  ```

  

* 移位指令

> 1. 移位次数由指令中的计数值所决定，可以是1次或由存放在CL中的无符号数指定。
>
>    这些指令均有统一的 指令格式： 
>
>    * 操作码 OPD，1 (8086／8088)      
>    * 或 操作码 OPD，CL (80X86) 
>
> 2. 移位指令包括算术移位指令、逻辑移位指令 和循环移位指令
>
> 3. 任何一条移位指令最后移出的1位二进制数总 是存入CF中。
>
> 4. 可以利用移位指令来实现快速的乘除法， 比直接使用乘除指令快。
>
>    * 逻辑移位指令实现无符号数乘、除法 运算,只要移出位不含1
>    * 算术移位指令实现有符号数乘除法运 算，只要移位操作不改变符号位
>
>    eg:
>
>    ```assembly
>    ;某数乘4或除4的运算。
>    MOV   CL，2
>    SHL    AX ，CL      ;AX中的无符号数乘4
>    SHR    AX， CL      ;无符号数除以4
>    SAR    AX， CL      ;有符号数除以4
>    ```
>
>    

## 算术左移SAL和逻辑左移指令SHL

`SHL(SAL)  OPD，1 或 SHL(SAL)  OPD，CL`

* 功能：SHL与SAL指令功能完全相同。
* 将(OPD)向左移动1次或者CL指定的次数，最 低位补入相应的0，CF的内容为最后移出位的值。
* 用SAL/SHL指令可以实现对无符号数乘以2^n^ 的运算(n为移位次数)、但需注意溢出(CF)

## 逻辑右移指令SHR

`SHR OPD，1    或 SHR OPD，CL`

* 功能：将(OPD)向右移动CL规定的次数，最高位补入相应个数的0，CF的内容为最后移出位的值
*  用SHR指令可以实现对无符号数除以2^n^的运 算(n为移位次数) 、但需注意余数1(CF)

## 算术右移指令SAR

`SAR  OPD，1 或 SAR  OPD，CL`

* 功能：将(OPD)向右移动CL指定的次数且最高位保持不变；CF的内容为最后移出位的值。
* 用SAR指令可以实现对有符号数除以2^n^的运 算(n为移位次数)、但需注意余数1(CF)

## 循环移位指令

> * 循环左移指令 ROL OPD，1/CL 
> * 循环右移指令 ROR OPD，1/CL 
> * 带进位位循环左移指令 RCL OPD，1/CL 
> * 带进位位循环右移指令 RCR OPD，1/CL
> * 前两条指令未把标志位CF包括在循环的环中， 而后两条指令把CF包括在循环中，作为整个循环的一部分。

### eg1:将一个2位的压缩BCD码转换成二进制数。

```assembly
DATAS SEGMENT
	BCD DB 01011001B ;59H
	BIN DB ? ;转换为59D
DATAS ENDS

CODES SEGMENT
ASSUME CS:CODES,DS:DATAS
	START:
	MOV AL,BCD
	MOV BL,AL
	AND BL,0FH ;BL存放低4位
	
	MOV CL,4
	SHR AL,CL ;AL现存放高4位
	MOV BH,10D
	MUL BH
	ADD AL,BL
	MOV BIN,AL  ;两位BCD码表示的最大数小于（2^8－1）
CODES ENDS
END START
```

### eg2:把一组寄存器CX:BX:AX中的一个48位二进制 数整体逻辑左移一位

```assembly
SHL AX,1
RCL BX,1
RCL CX,1
```

如果要求左移4位，如何实现？

```assembly
SHL AX, 1      ; AX循环左移1位
RCL BX, 1      ; BX循环左移1位
RCL CX, 1      ; CX循环左移1位

SHL AX, 1      ; AX循环左移1位
RCL BX, 1      ; BX循环左移1位
RCL CX, 1      ; CX循环左移1位

SHL AX, 1      ; AX循环左移1位
RCL BX, 1      ; BX循环左移1位
RCL CX, 1      ; CX循环左移1位

SHL AX, 1      ; AX循环左移1位
RCL BX, 1      ; BX循环左移1位
RCL CX, 1      ; CX循环左移1位

```

如果改为循环左移一位，程序应该如何修改？ 

```assembly
PUSH AX
RCL AX
RCL BX
RCL CX
POP AX
PCL AX
```

# 转移和调用指令

## 分类

1. 按转移的范围：根据转移指令与目标指令 是否属于同一个逻辑段
   * 段内、近程(NEAR)转移：仅仅修改IP(16位)
     * 其中，短(SHORT ) 转移：加上一个8位的相对位 移量以修改16位IP；
   * 段间、远程(FAR)转移：同时修改IP和CS
2. 按获取目标指令地址的方法
   * 直接：转移指令使用标号或过程名作为转移的目标
     * 标号：是定义在目标指令前面的一个符号名，代表目标指 令所在存储单元的逻辑地址。注意：标号必须区分类型： NEAR / FAR。
   * 间接：目标地址事先位于寄存器或者某几个存储单 元，当CPU执行JMP等转移指令时, 将寄存器或内存 单元内的有效地址写入IP或EIP, 从而实现转移。

3. 按是否存在转移条件
   * 无条件转移和条件转移指令

## 无条件转移指令JMP

*  无条件转移指令的执行结果不影响标志位
* 段内、近转移
  * `JMP  [ NEAR   PTR ] 标号`
  * 目标指令地址相对于当前转 移指令地址的相对位移量介于范围：-32768~  ＋32767 (16位相对位移量) ，转移范围基本上 可以覆盖整个逻辑段；
* 段内、短转移
  * `JMP  SHORT  标号`
  * 目标指令地址相对于当前转移指令地址的相对位移量介于范围： 128~+127 (8位相对位移量)
  * 短转移指令的优点：长度比段内、短转移指令节省一个字节。

* 段内、间接转移
  * `JMP  [ NEAR   PTR ]  寄存器操作数`
  * `JMP  [ NEAR   PTR ]  存储器操作数`
  * 寄存器、内存单元存放的是用于修改 IP的偏移地址EA！
  *  所谓“间接”，是指当CPU执行指令时，将寄存器或内存单元内的有效地址写入IP或EIP， 从而实现转移
* 段间、直接转移
  * `JMP   [ FAR   PTR ]  标号`
  *  指令中直接给出转向的4字节的偏移量和段基址, 执行时将偏移量送IP、段基址送CS，即可 实现段间直接转移。
  * 一个模块中不同的指令段之间或者在模 块化程序设计中，从一个模块转移到另一个 模块：必须执行段间转移指令。
  * 现代操作系统允许多道程序并发执行、且每道程 序可能包含多个代码段(最多2^14^个段)
* 段间、间接转移
  * `JMP  [ FAR   PTR ]  存储器操作数`
  * (IP) ←目标指令所在存储单元的EA
  * (CS)←目标指令所在存储单元的段地址(EA+2)

### eg1

已知：(DS)＝2000H，(BX)＝0300H，(IP)＝0100H， (20300H)＝12H，(20301H)＝34H。

1. `JMP  BX` ;执行后(IP)＝？ 
   * (IP)＝(BX)＝ 0300H

2. `JMP  WORD  PTR  [BX]`

   * 指令执行时，首先根据存储器操作数寻址方式得到目标指令所在存储单元的地址： 10H ×(DS)＋(BX)＝ 20300H

   * 再从该单元开始连续读取2个存储单元的内容，从而 获得转移地址：EA＝(20300H)＝3412H

   * (IP)＝EA＝3412H，下一次便执行CS:3412H 处的指令，实现了段内间接转移

### eg2

已知：(DS)＝2000H，(BX)＝0300H，(IP)＝ 0100H，(20300H)＝ 0，(20301H)＝ 05H，(20302H) ＝10H，(20303H)＝60H。

1. `JMP  DWORD PTR  [BX]`
   * 式中DWORD  PTR  [BX]表示BX指向一个双 字变量。指令执行时，先按照与操作数有关的寻址 方式得到存放转移地址的内存单元：10H×(DS)＋ (BX)＝ 20300H。
   * 再把该单元中的低字送给IP，高字送给CS，即 0500H →IP，6010H→CS,下一次便执行6010:0500H 处的指令，实现了段间间接转移。

## 条件转移指令

`操作码助记符 转移地址标号`

* 根据上一条指令对标志寄存器中状态 标志位的影响来决定程序执行的流程
* 若满足条件时：跳转到目标标号处的指令执行；否则，顺序执行转移指令后面的下一条指令。

### 根据：单个状态标志

| 标志 | 为1时转移                 | 为0时转移    |
| ---- | ------------------------- | ------------ |
| ZF   | JZ(JE)   结果为0/相等转移 | JNZ(JNE)     |
| SF   | JS  负数转移              | JNS          |
| OF   | JO   溢出转移             | JNO          |
| PF   | JP(JPE)  偶转移           | JNP(JPO)     |
| CF   | JC(JB(JNAE))  有进位转移  | JNC(JNB/JAE) |

### 根据：无符号数的大小

记忆方法: A:大于， B:小于， E:等于

![image-20241221162657513](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241221162657513.png)

### 根据：有符号数的大小

![image-20241221164158727](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241221164158727.png)

### eg1

> 设有10个字节属性的数据存放在以 2000H单元为首地址的数据缓冲器中,试编程实现找出其中的最大数,并存入2100H单元。

```assembly
MOV BX,2000H ;缓冲区首地址
MOV AL,[BX]  ;10个数据：假设第一个数即为最大
MOV CX,9
LAB:
	INC BX
	CMP AL,[BX]
	JAE LABEL
	MOV AL,[BX]
LABEL:
	DEC CX
	JNZ LAB
	
	MOV BX,2100H
	MOV [BX],AL
```

循环思路：

```assembly
MOV BX,2000H ;缓冲区首地址
MOV AL,[BX]  ;10个数据：假设第一个数即为最大
MOV CX,9
LAB:
	INC BX
	CMP AL,[BX]
	JBE NEXT
	MOV AL,[BX] 
NEXT:
	LOOP LAB
	
	MOV BX,2100H
	MOV [BX],AL	
```

### eg2

> 假设X为某值且存放在寄存器AL中，求出函数值f(x)并存放在AH中
>
> f(x) = 0,x=0
>
> f(x)=1,x>0
>
> f(x)=-1,x<0

```assembly
CMP AL,0
JGE BIG
MOV AL,0FFH
JMP DOWN
BIG:
	JE DOWN
	MOV AL,1
DOWN:
	MOV AH,AL

```

## 循环类指令

### 循环指令LOOP

```assembly
MOV   CX，100         ;100次输送CX 
START：

 ...  ...       ;要执行100次的程序段

LOOP  START  ;CX≠0，转START执行

 ...  ...       ;CX=0，继续顺序执行

```

功能上，使用LOOP指令可用两条指令代替： •

```assembly
DEC  CX 
JNE  SHORT 标号
```

### 相等/为零循环指令LOOPE

`LOOPE 标号，或 LOOPZ 标号`

* 功能：

  * (1)(CX)－1 → CX； 

  * (2)如果(CX) ≠0且ZF=1，则程序转移(循环)； 否则，顺序执行

* 应用场合

  * 比较两个字符串/数组/文件是否相同(出现第 一个不相等的数据则终止循环)。

### 不相等/不为零循环指令LOOPNE

`LOOPNE 标号，或 LOOPNZ 标号`

* 功能：

  * (1)(CX)－1 → CX； 

  * (2)如果(CX) ≠0且ZF=0，则程序转移(循环)； 否则，顺序执行

* 应用场合

  * 在一片数据区域(一个字符串/数组/文件)中， 寻找第一个等于给定关键字(例如0)的数据

#### eg1

在指定的字节型数据的存储区中，查询 第一个等于关键字X的数据元素所在的地址。

* 设存储区开始单元的偏移地址在BX中，最后单元的偏移地址在DI中；
* 若找到关键字数据，则将其偏移地址存放在 BX中；
* 若没有找到，则循环结束时必有BX与DI相等， 表示已搜索至最后单元。

```assembly
SUB DI,BX
MOV CX,DI
NEXT:
	CMP BYTE PTR [BX],'X'
	INC BX
	LOOPNZ NEXT
	JZ FOUND ;找到
	.....；没找到
FOUND:  ;找到：(BX)即为关键字
	......
```

#### eg2

编程实现：找出以ARRAY为 首地址的100个字型数组中的第一个非0 项（不等于关键字0），送AX中

```assembly
DS： ARRAY DW 0，0，0，1010H，··· ;（100个数）
CS：对DS初始化
MOV    CX，100
LEA BX，ARRAY
MOV SI，0FFFEH       ;－2，修正下列的INC
ZERO： 
	INC SI
	INC SI
	CMP  WORD PTR [BX+SI]，0  ；关键字是0
 	LOOPZ ZERO         
MOV AX，[BX+SI]
```

### CX为零转移指令JCXZ

`JCXZ  标号`

功能：

* 如果(CX) ＝0 则程序转移(循环)；否 则，顺序执行

# 子程序调用与返回指令

call

子程序即过程

# 中断调用及返回

1. `INT  n `
   * INT n指令类似于CALL指令，但是每次压栈 时必须同时保护3个寄存器，入栈顺序是 FLAGS、CS、IP。
2. 中断返回指令`IRET`
   * 该指令为中断服务程序的返回指令。 类似于RET，CPU总是依次从栈顶弹出6个字 节依次送入IP、CS、FLAGS寄存器(按中断 调用时的逆序恢复断点) ，从而返回主程序的 断点
