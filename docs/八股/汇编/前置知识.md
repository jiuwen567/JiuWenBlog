## 进制的书写规则

* 二进制数的100写成100 B 

* 八进制数的100写成100 O 

* 十六进制数100写成100 H

* > 注意：如果以字母A~F开始的16进制数，前面加0,以避免和符号名发 生混淆。如(F5) 16 =0F5H。

* 十进制数100可以写为100D，省略后缀字母时默认为十进制数

## 求补运算

* 正数

  * 原码、反码、补码相同

* 负数

  * 法一：反码+1

    * 反码为：第一位符号位不变，后面相反

    * eg: [-46]补码

      [-46]原码 =  1 0 1 0  1 1 1 0

      [-46]反码 =  1 1 0 1  0 0 0 1 

       [-46]补码 = 1 1 0 1  0 0 1 0   =   D2H

  * 法二：从低位开始向高位观察，遇见第一个1，则 将包含第一个1在内的所有低位数值0保持不变，将包括符号位在内的所有高位取反。（求补运算）

    * eg: [-46]补码

      [46]

      0 0 1 0  1 1 1 0

      1 1 0 1  0 0 1 0   =   D2H

    * > “求补运算”适用于：
      >
      > 1.求一个负数真值的补码：对正数补码执行求 补运算； 
      >
      >  2.求一个负数补码的真值； 
      >
      >  3.把补码减法变成加法：减去一个数，等于加 上一个数的相反数，从而可以把减法转换成 加法。这个过程实际上就是求：一个补码的 真值的相反数的补码

      

## 补码运算

> 补码表示法的运算特点是：将*符号位*视为数 据位直接参与运算、从而简化了加减运算的 硬件电路；
>
> 由于加减运算最为频繁，因此现代计算机中 普遍使用补码作为有符号数的表示方式

1. * 公式1：[X+Y]补=[X]补+[Y]补。 
   * 公式2：[X–Y]补=[X+(–Y)]补=[X]补+[–Y]补

2. 参加运算的两个操作数均用补码表示；
3. 补码减法可用加法替换；
4. 运算结果为补码；
5. 进位值CF无论是0或1：对补码运算结果(对/ 错)均无影响！！！
6. 当运算结果超出字长能够表示的合法范围时， 结果就不再正确。此时称为溢出！
7. 为了让程序员获知有符号数补码运算过程中 的溢出信息，现代CPU中普遍设置了一个专 门的硬件触发器：溢出标志位触发器：OF！

## 标志位

### 进位标志CF

1. 对于有符号数（补码）的运算，CF中的进位值无论 是0还是1，都没有意义，即：进位值CF不能统计在 运算结果之中。

### 溢出标志OF

> 溢出：当两个二进制数(有/无符号数)进行运算时， 若运算结果超出一个机器数的表示范围时(运算装置 的容量有限)，就不能正确表示数了，此时称为溢出。

1. 对于无符号数的运算，OF中的值无论是0还是1，都没有意义。
2. 有符号数(补码)运算中考查OF才有意义

## 浮点数

### 定义

* 浮点数是小数点可以左右移动的数。 

 例如：45.3125 = +101101.0101 = +0.1011010101 × 2+6 • = +1011010101 × 2-4 • 

即可以写成二进制格式：±S×2±J • 

其中：+/-J为阶码(Exponenet)，表示小数点 位置；+/-S为尾数(Mantissa或者Significand)。

### 规范化

* 由于一个浮点数在机器中可以有多种表示，运算时 不方便，故对其进行规格化，使得表示方法唯一。 • 

* 浮点数的规格化(Normalized)定义：一个规格化的 浮点数真值满足：

1)尾数为纯小数，且小数点后第一位为1； • (2)阶码为整数。 

例如:45.3125 的规格化数为：+0.1011010101×2+6 而不是+0.01011010101×2+7 也不是+101.1010101×2+

## BCD码

### 	分类

#### 压缩/组合BCD码 

 每一位数采用4位二进制数来表示，则一个字节(包 含8位二进制数)可以表示两位十进制数。 •

例如：二进制数1000 1001B，采用压缩BCD码表示 为十进制数89D。 •

####  非压缩/未组合BCD码

 每一位数采用8位二进制数来表示，即一个字节表示 一位十进制数。而且只用每个字节的低4位来表示 0～9，高4位为0。

例如：十进制数89D，采用非压缩BCD码表示为二 进制数必须使用2个字节，即：00001000B和 00001001B。

## 关于8086/8088

8086/8088 CPU可以访问两个独立的地址空间：

1. 存储器地址空间（Memory Address Space）

   - 8086和8088的存储器地址空间的大小都是**1MB**。这是因为它们使用20位地址总线，可以寻址

      2^20^个地址位置，即 1MB的内存。

2. I/O地址空间（I/O Address Space）

   - 8086/8088有**64KB**(2^16^B)的I/O地址空间。该空间分配给了输入/输出设备，地址范围从 0x0000 到 0xFFFF（总共 65536 个地址位置）。