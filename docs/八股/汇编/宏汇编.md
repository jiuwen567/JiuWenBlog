## 汇编语言源程序到可执行文件的处理过程

![image-20241224153647815](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241224153647815.png)

1. 用编辑程序建立以ASM为后缀名的源文件。
2. 用汇编程序(MASM.EXE)把源文件转换成OBJ 目标文件。
3. 用连接程序(LINK.EXE)把目标文件转换成EXE 执行文件。
4. 用DOS命令方式直接键入文件名，执行

* asm或.c： 

* .obj：由机器指令代码构成 

* .exe或.com：一个完整的可执行文件

## 伪指令

>  伪指令，又称为伪语句，是汇编语言提供的指示性语言，为汇编程序和连接程序提供信息。
>
> 伪指令本身不占用内存单元，它们的功能是在汇编和连接时由相应的软件完成的

### 常量、变量与表达式

#### 常量

>  常量包括立即数、字符串常数和符号常数。

1. 立即数
   * 如：125，125D，0A9H，10101010B， 11Q，－200。 
   *  立即数的数制用在数字之后添加后缀字母来表示， 后缀‘D’(或者缺省)表示十进制数，后缀‘H’表示 十六进制数，后缀‘B’表示二进制数，后缀‘Q’表 示八进制数。 
   * 立即数必须以数字开头，以字母A-F开头的十六进 制数必须加前缀数字0。
   * 经过汇编之后，汇编程序将把各种进制表示的立即 数全部转换成等值的二进制数，负数转换成补码。

2. 字符/字符串常数

   * 用单引号括起来的字符串称为字符串常数。 如‘A’，‘A1B2C3’。
   * 经过汇编之后，单引号中的每个字符将被转 换成相应的ASCII码，可以像使用立即数一样 使用它们。
   * eg: MOV AL，‘A’  ；寻址方式？AL = 41H

3. 符号常数

   *  符号常数用等值伪指令“EQU”或者等号伪指令 “＝”定义。

   * 使用符号常数有利于程序调试，增加程序的可读性。

   * 符号常数经过定义之后，实际上作为立即数使用。

   * eg:

     ```assembly
     PI   EQU   314
     X = 100
     MOV AX，PI    ;AX＝314
     MOV DX，X     ;DX = 100
     ```

   * 符号常数不同于符号地址、是：立即数！(类似于 #define )

   * 符号地址本质上是地址。

   * 等值伪指令`EQU`和等号伪指令`=`的区别

     * 用EQU伪指令定义的符号常数，其值 在后续的程序中不能更改(能够避免程序员无意间重 复定义符号名) ；用等号伪指令定义的符号常数，在 后续的程序中可以重新定义，从而达到修改所定义 的符号常数的目的

### 符号地址

* 变量：代表内存操作数所在存储单元的存储地址， 或者说变量名就代表某个存储单元。 
* 标号：代表指令所在存储单元的存储地址，它为转移指令提供了转移目标。
* 标号被定义在代码段，变量通常被定义在数据段、附加段或堆栈段。
* 由于标号和变量是用一串字符命名的，从这个意义上讲，变量和标号可以统称为符号地址。
* 理解：包括子程序名、段名皆是如此！
* 作为符号地址，具有共同的3个属性。
  * 段属性。即标号或变量所在段的段基址， 用SEG运算符可以计算得到。
  * 偏移属性。即标号或变量所代表的存储单 元，相对于段基址之间的偏移地址(或称有效地址)，用OFFSET运算符可以计算得到。
  * 类型属性
    * 变量的长度类型属性有字节型、字型、双字 型、四字型等等
    * 用DB伪指令定义的变量，其所属的单元均为 字节型
    * 用DW，DD，DQ伪指令定义的变量，其所属 的单元分别有字型、双字型和四字型属性

### 返回属性或数值的运算符

1. SEG运算符

   * `SEG 段名`

   * 功能:计算某个逻辑段的段基址。

   * ```assembly
     MOV  AX，SEG  DATA
     MOV  DS，AX
     ```

   * 后跟段名时，SEG运算符可以省略。

   * SEG实际上也可以针对该逻辑段中任意一 个符号地址：变量名、标号(已验证！)或者子程序名进行计算

2. OFFSET运算符

   * `OFFSET 变量名或者标号名`

   * 功能:计算变量名或者标号名代表的存储单元 相对于所在段的段基址的偏移/有效地址。

   * ```assembly
     BUF  DB   12，34，56
     ……
     MOV  AX， SEG 数据段的段名
     MOV  DS， AX
     MOV  BX，OFFSET BUF
     MOV  AL，DS:[BX]
     ```

     * 首先求出BUF的偏移地址并赋给BX，然后对 BX间址取数送到AL，所以(AL)=12。

   * 如果仅仅只需访问一个特定的存储单元，那 么最后两条语句可以合并为MOV AL，DS:[BUF]

   * 实际上为了利用循环程序处理连续多个存储 单元的数据，经常采用[ BX ]这种寄存器间接寻址的 做法。

### 修改类型属性的运算符PTR

`类型说明符 PTR 符号地址`

1.  其中类型说明符包括： 
   * 变量名时：BYTE(字节)，WORD(字)，DWORD(双 字)； 
   * 标号或子程序名时：FAR(远)，NEAR(近)。

2. 变量名具有默认的类型属性。
   * eg:使用DB ABC定义：变量名ABC为字节类型
     *  MOV  DS:[BX],12H ；错误  因为无法指明操作数的长度类型
     * MOV DS:[ABC],12H ；正确
3. 程序中可能出现不匹配的情况，此时：可以 使用PTR运算符：临时修改变量名的类型属性。
   * eg: 已经指明ABC为字节类型的变量名，
     * 那么： MOV AX,  ABC    ；错 
     * MOV AX , WORD PTR ABC      ；对

### TYPE运算符

` TYPE  变量名或者标号名`

* 功能:计算变量或者标号的类型。
* 对于字节、字或双字型的变量名返回的值分 别为：1，2，4。
* 于NEAR和FAR型的标号分别返回-1，-2.

### 数据/变量定义伪指令

> 此类指令的核心功能是：要求编译程序为用户程序分配若干存储单元
>
> 注意：此类伪指令前面可以为存储单元定义变量名。

#### 字节定义伪指令

` [变量名]  DB 一串用逗号间隔的字节型数据`

##### eg1

* ```assembly
  BUF1  DB  55，66H，7*7
  DB    ?,?
  ```

* DB是Define Byte的缩写,DB伪指令定义的变量名及存储单元的默认属性为 “字节型”。

* `*`操作 由 由汇编编译器完成

* `？`代表随机数

##### eg2

```assembly
BUF1  DB  55,66H7*7
DB    ？，？
COUNT1 EQU   $ - BUF1 ;COUNT1为？
BUF2   DB  10 DUP( 12H, 2 DUP (12, 34))
COUNT2   EQU   $ - BUF2 ;COUNT2为？
COUNT3   EQU   $ - BUF1 ;COUNT3为？
```

* DUP是Duplicate的缩写，翻译为“重复”，DUP左边是 重复系数，右边圆括号中为需要重复设置的数据。DUP操作 符可以嵌套使用
* $运算符的含义：汇编过程中，地址计数器中的内容(地址的当前值)。最常见的用法：与符号常数定义伪指令配合，紧 跟在数据定义伪指令之后，用于统计从某个变量地址开始、 至当前指令为止，所分配的存储单元数目(经常用于循环程序的次数)。
* `COUNT1 = 5`（`BUF1` 总共 5 个字节）
* `COUNT2 = 50`（`BUF2` 总共 30 个字节）
* `COUNT3 = 5 + 50 = 55`（`BUF1` 和 `BUF2` 总共 55 个字节）
* `COUNT1` 不是一个变量名,不会分配存储单元，它只是一个符号常量，在汇编时由汇编器替换为其值。

#### 字定义伪指令

`[变量名] DW 一串用逗号间隔的双字节数`

* DW是Defined Word的缩写，DW伪指令的功能是 通知汇编程序，把所定义的双字节数从指定变量开 始依次存放，每一个双字节数的存放规律是：低位字节存入低地址单元(i单元)，高位字节存入高地址 单元(i+1单元)。
* 出现在DW伪指令中的字符串常数，单引号中只能是一个或两个字符。

* `WNUM DW 1234H，56，’AB’，’C’，?`经汇编之后，WNUM~WNUM+9存储单 元中存放数据的次序依次是34H，12H，38H，00H，42H，41H，43H， 00H，××，××。
  * `MOV AL, BYTE PTR WNUM+1 `AL = 12H
  * `MOV AX, WNUM+1` AX = 3812H
  * `WNUM+1`只会加1字节

#### $运算符

* 在汇编程序对源程序汇编的过程中,使用地址计数器 来保存当前正在汇编的指令的地址
* 地址计数器的值可用\$来表示,汇编语言允许用户直 接用$来引用地址计数器的值
* 汇编语言程序中，符号“$”表示当前偏移地址值
* `JMP  $-3`
  * $此处为JMP下一条指令地址， 假设该JMP指令长度为3。故：本指 令实际上跳转回JMP自身！
  * 构造一个形式上的死循环，实际应用于一个无限循环的中断响应系统。

#### 双字定义伪指令

`变量名] DD一串用逗号间隔的4字节数`

* 通知汇编程序，把DD定义的数从指定 的变量名开始依次存放，每一数占4个单元， 每一个数的存放规律也是低位字节存入低地 址单元，较高字节存入较高的地址单元。

### 段约定语句

`ASSUME  段寄存器：段名，…，段寄存器：段名`

* 例如：`ASSUME CS:CODE,DS:DATA`

* ASSUME语句是非执行的语句，要求放在代码 段之中、执行寻址操作之前；习惯上，把ASSUME 语句作为代码段的第1条语句

* ASSUME没有实现初始化，部分段寄存器的初值必须在程序中用指令重新设置

  * 有两个办法可以设置段寄存器的初值

    设DATA为数据段段名:

    * 使用SEG运算符求出逻辑段的段基址赋给段 寄存器，如:

      ` MOV    AX，SEG DATA  ` 

      `MOV    DS，AX`

    * 省略SEG、直接把段名赋给段寄存器，如:

      ` MOV    AX，DATA  ` 

      `MOV    DS，AX`

## DOS系统功能调用

`MOV  AH，功能号`

 `设置入口参数 `

`INT   21H  `

`分析出口参`

1. [功能号01H]键盘输入并回显

   * 等待用户从键盘上输入一个字符，有回显， 响应Ctrl-C。此调用的功能是系统扫描键盘 并等待键盘输入一个字符，有键按下时，先 检查是否是Ctrl-C键，若不是则将字符的键 值(ASCII码)送入AL寄存器中，并在屏幕上 显示该字符。

   *  入口参数：无。 

   * 出口参数：AL=按键的ASCII码。

   * 下列语句可实现键盘输入。

     ```assembly
     MOV AH，01H        
     INT 21H
     ```

     

2. [功能号02H]在显示器上显示一个字符，响应Ctrl-C。

   *  入口参数：DL=等待显示字符的ASCII码。 

   *  出口参数：无。

   * 在屏幕上显示’A’符号

     ```assembly
     MOV DL，’A’
     MOV AH，02H
     INT 21H
     ```

   * 实验表明，该功能会破坏AL寄存器的值。

   * 可以使用不可显示的控制字符。例如，用于实现格式控制的换行(0DH)、回车 (0AH)字符等

3. [功能号09H]显示字符串，响应Ctrl-C。

   * 入口参数：DS:DX=字符串首地址，即待输出 字符串的首字符的逻辑地址
     * 字符串必须以字符‘\$’作为结束标志，但’$’ 不会显示在屏幕上。
   * 出口参数：无。
   * 实验表明，该功能会破坏AL寄存器的值，不 改变其余寄存器及标志寄存器的值。

4.  [功能号0AH]等待从键盘上输入一个字符串(必须以 回车符表示结束)，然后存入内存中的数据缓冲区。 有回显，响应Ctrl-C。

   * 入口参数：①DS:DX=数据缓冲区首地址；②首字节单元指出允许最大输入的字符串长度(包含 回车符) 。
   * 出口参数: ①在缓冲区第二个字节单元存放实际输入字符串的长度(不包含回车符)； ②从第三个字节单元开始存放实际的字符串，其中 一个存储单元存放回车符的ASCII码0DH(十进制的 13)。
   * 如果输入的字符个数超过规定值，系统则会发出声 音警告信息。缓冲区不接收超长字符.
   * ![image-20241226124722513](https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241226124722513.png)

   * 用户键入回车之后，由0AH功能把实际键入 的字符个数(不包括回车符)写入BUF+1单元。

   * 键入的字符串从BUF+2单元开始依次存放。 因此，缓冲区的容量要大于(或等于)键入串的 长度(包括回车符)+2

   * eg: 

     ```assembly
      BUF  DB  15
      DB   ?
      DB 15 DUP(?)  
     ;或者 BUF   DB  15，?，15 DUP(?)
     
     ;允许用户输入14个字符，因为还有1个回车
     
     MOV  AH，0AH
     LEA  DX， BUF
     INT   21H
     
     ```

5. [功能号4CH]终止当前程序的运行，并把控制权转交给调用它的主程序。

   * 该项功能同时将程序用过的内存空间交还给DOS另 行分配，由被终止程序打开的全部文件都被关闭。

   * 即：在用户程序末尾添加以下两条语句：

     ```assembly
     MOV AH，4CH
     INT 21H
     ```


## 宏指令

> * 宏指令在形式上是由程序员自己定义的新指令
> *  但实质上是由CPU指令系统中多条真实指令构成的 一个集合。
> * 宏指令执行的原理是：汇编时替换为真实指令集合， CPU依次执行宏指令所包含的各条指令语句。
> * 宏指令分为无参数宏指令与有参数宏指令两种。
> * 宏指令的定义语句可以放在逻辑段之外，通常都放 在程序的首部，但调用指令仍需放在代码段内。
> * 对于宏指令，由于每一次宏调用都要进行宏展开， 把宏体中的内容复制一遍，因而用宏编写的程序在 目标代码中会重复出现相同或相似的程序段，占用 内存空间大；所以，频繁调用宏指令会增大目标程序的尺寸

### 无参数宏指令

格式：

```assembly
宏指令名称  MACRO
		宏体
		ENDM
```

eg-DOS功能调用: 

```assembly
RETN MACRO
 	MOV  AH，2
 	MOV  DL，0DH
 	INT  21H
 	MOV  DL，0AH
 	INT  21H
 	ENDM
```

### 有参数宏指令

格式：

```assembly
宏指令名称  MACRO 哑元表
		宏体
		ENDM
```

### 条件汇编伪指令

格式：

```assembly
格式1:
	IF 条件格式
	指令集合
	ENDIF

格式2:
	IF 条件
	指令集合1
	ELSE 
	指令集合2
	ENDIF
```

