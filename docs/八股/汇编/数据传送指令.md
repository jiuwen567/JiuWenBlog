## 数据传送指令

1. 通用传送指令
2. 堆栈传送指令
3. I/O传送指令

## 通用传送指令

## MOV指令

`MOV 目标操作数，源操作数`

将源操作数传送入目的地址，源地址内容不变，不影响状态标志。即：(源操作数)→目标

### 语法规则

* 立即数不能作为目的操作数

  * 例：  MOV 1234H，AX  ；非法指令

* 源、目的操作数不能同时为存储器操作数。

  * 例： • ADD  [DI]，[SI]   ；非法指令

* CS或IP不能作为目的操作数，任何以CS或IP为目标 的传送指令都是非法的

*  源操作数是立即数时，段寄存器不能作为目的操作数。

  * 例：MOV DS，1000H   ；是非法指令

  * > 为了把立即数的值传送给段寄存器，通常可以借用 一个寄存器/存储器操作数作为过渡。例如：  MOV AX，DATA  ；DATA为数据段名 ；编译后即为DATA段的段基址、立即数 •MOV DS，AX

* 任何一条指令必须明确(例如包含 寄存器或使用PTR)/隐含指定每个操作数的类型(长度)！

* 大多数指令要求源操作数和目的操作数必须等长(即：类型匹配)。传送类指令大多如此

  > 例：MOV [BX]，12H     ；错误。源、目的操作数都无法指明数据长 度！！
  >
  > 双操作数指令中，当源操作数是立即数、 目操作数是寄存器间址类(非变量名)的存储 器操作数时，对目标操作数的存储操作数必 须说明长度类型！！
  >
  > 可以改为： MOV  BYTE PTR [BX]，12H  
  >
  > 或者 MOV  WORDPTR[BX]，12H  
  >
  > 或者 MOV  DWORDPTR[BX]，12H  

* 对于变量名方式的存储器操作数

  * > 例1： • XYZ DB 12H         ；定义XYZ为字节型变量 
    >
    > • MOV  XYZ，12H   ；操作数为8位 • 
    >
    > 例2： • XYZ DW 12H         ；定义XYZ为字型变量 •
    >
    >  MOV  XYZ，12H    ；操作数为16位 • ；变量名定义时具有默认的长度属性，无需使用 PTR说明！

* 如果源、目的操作数类型不匹配，同样需要使用PTR进行说明

  * > XYZ DB 12H         ；定义XYZ为字节型变量 • MOV AX，XYZ    
    >
    >  错：AX是字操作数，而XYZ是字节变量。
    >
    > 应该改为：  MOV AX，WORD  PTR XYZ ;正确

* 类似地，在单操作数指令中，当目的操作数 是寄存器间址类(非变量名)的存储器操作数 时，同样需要对存储器操作数说明长度类 型！！！ 

### 符号扩展传送指令MOVSX

`MOVSX DST，SRC`

将SRC的符号位向高位扩展，使源操作数与 目标操作数字长相同、但真值不变，再送到DST， 而SRC保持不变。(386以上)

* DST为REG16或REG32，SRC为小于等于DST的 立即数或存储器操作数或寄存器操作数。 •

* 对于有符号数才有意义。对于有符号数的补码， 扩展前后的真值保持不变，只有补码的位数不同。 

* 对于无符号数无意义

#### eg

```assembly
MOV  CL,56H
MOVSX  AX,CL ;0101 0110 B ;0000 0000 0101 0110 B 
```

* AX中得到56H的带符号扩展值0056H

```assembly
MOV DL,0FEH        ;1111 1110 B 
MOVSX  AX,DL ;1111 1111 1111 1110 B  ;
```

 AX中得到88H的带符号扩展值0FFFEH

### 零扩展传送指令MOVZX

`MOVZX DST，SRC`

将SRC的高位用0补充，使其与目标操 作数字长相同，再送到DST，而SRC保持不变。(386以上)

* DST为REG16或REG32，SRC为小于等于 DST的立即数或存储器操作数或寄存器操作 数。

* 对于无符号数才有意义，扩展前后无符号数的真值不变。

  ```assembly
  MOVZX EAX，CX
  ```

### 有效地址送寄存器指令LEA

load effective address, 加载有效地址，可以将有效地址传送到指定的的寄存器。指令形式是从存储器读数据到寄存器, 效果是将存储器的有效地址写入到目的操作数, 简单说, 就是C语言中的”&”.

`LEA REG,SRC`

源操作数SRC必须是存储器操作数

REG为16位或32位寄存器(除段寄存器外)。 

等价指令：`MOV REG,OFFSET SRC`

eg: 

```asm
MOV DX, OFFSET INPUT_MSG
LEA DX,INPUT_MSG
```

会将 INPUT_MSG 的偏移地址（相对于其段基址的地址）加载到 DX 寄存器中。
此时，DX 存储的是 INPUT_MSG 在当前数据段的偏移量，而不是 INPUT_MSG 中的数据。

## 堆栈传送指令

> 堆栈操作单位是字(数据字长为16的倍数))

在80X86中，规定：

* SS段寄存器：用于指示堆栈段的段基址，即是：堆栈空间(段)中的地址最小的存储单元的地址(段基址)。 

* 栈底位置固定不变，即是：堆栈空间中最高地址的存储单元。(该地址由SS规定的段基址和预先定义的堆栈段的大小决定。) 

* SP或ESP(堆栈指针)始终指向栈顶，随着数据出栈、入栈操作而不断变化。 

* SP或ESP寄存器：存储堆栈中最后一个入栈数据(栈顶)所在存储单元的偏移地址。
* 数据进栈后，栈顶指针向低地址端调整；数据出栈后，栈顶指针向高地址端调整。
* 16位或者32位操作数
  * 入栈规律是：高位字节存入高地址单元，低位字节存入低地址单 元；
  * 出栈规律是：低地址字节弹到目标操作 数低位，高地址字节弹到目标操作数高位。

### 进栈指令PUSH

`PUSH  SRC`

执行时，首先调整堆栈指针，然后把源操作数压栈

注意：单操作数指令中：存储器操作数，需要用PTR说明操作数长度。该指令中单操作数为源操作数。

* eg:

  * ```asm
    PUSH  WORD PTR [BX]
    ```

### 出栈指令POP

`POP  DST`

先将栈顶弹出2个或4个字节，送目标操作数，然后调整堆栈指针。

## 算术运算类指令

### ADD加法指令

`ADD  目的操作数，源操作数`

* 功能：源操作数+目的操作数→目的操作数

* 影响的标志位：CF，OF，SF，ZF，PF，AF

* 两个操作数不能同时为存储器操作数

* 如果SRC是立即数，DST是存储器操作数， 则DST必须用PTR说明是字节还是字型或是双字型，否则汇编时会出错。

* ```asm
  ADD  AL,BL
  ADD  CL,6
  ADD  WORD  PTR [BX],56
  ADD  EDX,EAX
  ```

### ADC带进位的加法指令

`ADC 目的操作数，源操作数`

* 功能：源操作数+目的操作数+CF→目的操作数。将目的操作数加源操作数再加低位进位, 结果送目的地址。

* 影响的标志位：CF，OF，SF，ZF，PF，AF
* 该指令适用于多字节或多字的加法运 算；CF应是上一条指令执行后产生的C标志

* 两个32位二进制数分别存储在DX、 AX和BX、CX寄存器中。其中DX和BX存放 的是高位字，AX和CX存放的是低位字。请 实现两数的加法操作

  ```asm
  ADD AX，CX;低位相加
  ADC DX，BX ;高位
  ```

### INC加1指令

`INC  目的操作数`

* 目的操作数＋1 →目的操作数。
* INC指令是一个单操作数指令，操作数可以是寄存器或存储器操作数。常用于地址指针或循环次数实 现加1操作。
* INC指令不影响CF标志，但影响其他5个状态标 志(AF，OF，PF，SF，ZF)
* INC指令的操作数不能是立即数
* 当INC的操作数是存储器操作数时，必须用PTR 说明其长度属性。

### SUB减法

`SUB 目的操作数，源操作数`

* 目的操作数－源操作数→目的操作数， 目的操作数减去源操作数，结果存于目的地 址，源地址内容不变
* 影响的标志位：CF，OF，SF，ZF，PF，AF

### SBB带借位减法

`SBB  目的操作数，源操作数`

* 目的操作数-源操作数-CF→目的操作 数，目的操作数减源操作数、再减低位借位 CF，结果送目的地址。适用于多字节或多字 的减法运算。

### DEC减1

`DEC 目的操作数`

* 目的操作数－1→目的操作数。DEC 指令是一个单操作数指令，操作数可以是寄 存器或存储器操作数、不能是立即数。常用 于地址指针或循环次数实现减1操作
* DEC指令不影响CF标志，但影响其他5个 状态标志(AF，OF，PF，SF，ZF)；
* DEC指令的操作数不能是立即数
* 当DEC的操作数是存储器操作数时，必须 用PTR说明符说明其属性

### 加法、减法指令小结

* 目的操作数不可能为立即数; 

* 源、目的操作数必须要等长; 

* 源、目的操作数不能同时为存储器操作数; 

* 如果源操作数是立即数，目的操作数是存储器操作 数，需要使用PTR进行说明; 

* 以上指令中，除INC和DEC以外，都要影响所有6个 标志位。

* INC和DEC指令：仅有一个操作数，可以 是8/16/32位寄存器操作数或者存储器操作数。这两条指令操作结果均不影响**CF**标。(但其他5个状态标 志位都可能会影响。)

### CMP比较指令

`CMP  目的操作数，源操作数 `

* 功能：目的操作数－源操作数，不保存减法 结果、但正常影响各个状态标志位。 
* CMP类似于SUB指令，但不同的是： 该指令不保存相减的结果，因而不改变操作数，仅仅影响状态标志。
* CMP常用于转移指令之前，以形成转移条件， 状态标志包括6个：CF，OF，SF，ZF，PF， AF。

### 乘法指令

* MUL   无符号数乘法指令 

* IMUL  有符号数乘法指令

#### MUL无符号数乘法指令

`MUL  SRC ；单操作数格式`

* SRC指明乘数长度(不能是立即数)

* 被乘数和乘数须是等长的无符号二进制数、被乘 数隐含在累加器中(AL/AX/EAX)；

* 乘积为双倍字长

* 执行的操作：

  *  字节操作： (AX) <—(AL) * (SRC) 

  * 字操作： (DX，AX)<—(AX) * (SRC) 

  * 双字操作：(EDX，EAX)<—(EAX) * (SRC)

* 目的操作数必须是累加器AL、AX、EAX，源操作数是除立即数之外的寻址方式。

* 影响CF、OF标志位，其他不确定

* eg

  ```asm
  MOV BL，4
  MOV AL，64
  MUL  BL; (AH)=?  (AL)=? (AX)=？
  ;(AH)=01H，(AL)=00H ，(AX)=100H

#### IMUL有符号数乘法指令

`IMUL  SRC ;单操作数格式`

* 参与运算的被乘数、乘数、乘积均为有符号数，其他与MUL指令相同。

* ```asm
  MOV AL，-1
  MOV BL，1 1111 1111(补码)
  
  IMUL BL       ;视为有符号数; (AX)=？0FFFFH
  MUL BL       ;视为无符号数改为; (AX)=？00FFH
  

### 除法运算

#### DIV 无符号数的除法指令

`DIV SRC ;单操作数格式`

* SRC必须指明除数长度、不能是立即数；
* 被除数必须是除数的双倍字长、隐含存放在寄存器中；
* 商和余数与除数等长，分别存于被除数的低、高 半部分。
* 执行的操作：字节操作：16 位被除数放在AX中，8 位除数为源操作数。结果的8位商在AL中，8位余数 在AH中。表示为： (AL) <—(AX)/(SRC)的商；(AH) <—(AX)/(SRC)的余数；
* 字操作：32 位被除数在DX，AX中，16位除数为源 操作数。结果的16位商在AX中，16位的余数在DX 中。表示为：(AX) <–(DX，AX)/(SRC)的商，(DX)  <—(DX，AX)/(SRC)的余数
* 执行DIV，运算后对标志位无确定影响， 都没有意义。
* 商超过规定的范围，CPU自动执行0型中断服务程序。

##### eg1

```asm
MOV BL，4 
MOV AX，17 
DIV  BL    
```

* ;AX＝？
*  ;(AL)=4，(AH)=1 
* AX＝14H？× 
* AX = 104H  √

#### IDIV有符号数的除法指令

`IDIV SRC`

* 被除数、除数、商值和余数均为有符号补 码数，其他与DIV相同
* SRC必须指明除数长度不能是立即数
* 若被除数与除数等长时，必须扩展被除数的长度
  * 机器数的实际数值的正负、大小不变，仅将数的符号位扩展

##### eg1

```asm
MOV AX，-16
MOV BL，-3
IDIV  BL    
```

* 结果是(AL)=+5，(AH)= -1?
* 还是(AL)=+6，(AH)= +2 ?
* AL)=+5，(AH)= -1 √
* 规定：相除后余数的符号必须和被除数相同

### eg-算术指令的综合例子

> 计算(V-(X*Y+Z-540))/X其中X、Y、Z、V均为16位带符号数，已经分别装入X、Y、Z、V单元，要求上式的计算结果的商存入AX,余数存入DX寄存器。
>
> 程序设计考虑的问题：
>
> 1. 带符号数的运算的指令。 
> 2. 参与运算的符号的扩展问题。
> 3. 寄存器的占用问题。 
> 4. 计算结果的进位问题。
> 5. 计算的先后顺序问题。

```asm
;X*Y
MOV AX,X
IMUL Y
MOV CX,AX
MOV BX,DX

;+Z
MOV AX,Z
CWD ;16位Z变32位
ADD CX,AX
ADC BX,DX

;-540
SUB CX,540
SBB BX,0

;V-
MOV AX,V
CWD
SUB AX,CX
SBB DX,BX

IDIV X
```



## (长度)类型转换指令

> * 这类指令实际上是把操作数的最高位进行扩展； 
> *  常用于处理有符号数运算的操作数类型的匹配问题； 
> * 这类指令均不影响标志
> * CBW、CWD、CDQ几条指令常常用于配合有符号数除法指令中以实现被除数双倍字长的要求
> * 对比：在CPU字长允许的情况下，有时可用 MOVSX替代。例如： MOVSX AX , AL         ;等价于CBW

### CBW字节扩展成字

`CBW`

* 把AL寄存器中的符号位值扩展到AH 中，真值保持不变。

#### eg

```asm
MOV  AL,5
CBW ;(AH)＝0,AL值不变


MOV  AL,80H
CBW ;(AH)＝0FFH,AL值不变


MOV AL，-16
CBW      ;(AX)= -16                
MOV BL，-3
IDIV  BL

```

### CWD字扩展为双字

`CWD` 

* 把AX寄存器中的符号位扩展到DX中

#### eg

```asm
MOV  AX,5
CWD ;(DX:AX)＝00000005H


MOV  AX,9098H
CWD ;(DX:AX)＝0FFFF9098H

```

### CWDE字扩展为双字

`CWDE `(386以上)

* 把AX寄存器符号位值扩展到EAX的高 16位

#### eg

```asm
MOV  AX,5
CWDE ;(EAX)＝0000 0005 H


MOV  AX,9098H
CWDE ;(EAX)＝0FFFF 9098 H

```

### CDQ双字扩展为四字

`CDQ `(386以上)

* 把EAX寄存器中符号位值扩展到EDX中

#### eg

```asm
 MOV  EAX,5
CDQ ;(EDX:EAX)＝0000000000000005H


MOV  EAX,90980000H
CDQ ;执行结果为(EDX:EAX)＝0FFFFFFFF90980000H

```

## BCD码(十进制)调整指令

> * BCD码只能表示无符号数
> * 如何调整：4位二进制数表示的BCD码十进 制数与实际的4位二进制数所能表示的范围， 模相差为6，所以调整时对6进行处理。
> * 当BCD码表示的十进制加法运算用二进制进 行时，有两种情况需要进行调整： 
>   1. 运算的结果出现非法的BCD码(即4位BCD 码对应的十进制数大于9)；
>   2.  运算产生半字节间的进位(即：AF/CF=1， 表示4位二进制数加法产生了大于15的进位)
> * 调整的方法是加6进行修正。
> * 以上调整的判断和执行过程由CPU调整指令 自动进行!

### 压缩BCD码调整指令

#### DAA压缩BCD码加法调整指令

`DAA`

* 针对AL中的两个组合BCD码数(按二进制运算)之和进行调整，得到正确结果所对应的BCD码数。
* DAA 执行后影响A，C，P，S，Z标志，对 OF未定义

##### 指令执行时的调整过程

1. 如果AL的低四位大于9或者AF标志=1， 则AL的寄存器内容加06H且使AF = 1 ；否则不修正，AF不变
2. 如果AL的高四位大于9或者CF标志=1， 则AL的寄存器内容加60H且使CF = 1；否则 不修正，CF不变。

##### eg1

压缩BCD码的加法运算：计算18+27=?

```assembly
MOV AL,18H
ADD AL,27H ;二进制加法
DAA ;十进制加法调整
```

##### eg2

假设数据段中BCD1和BCD2字单元均为组合BCD码(4 位BCD码数)，计算这两BCD码数之和，存入SUM字单元中

```assembly
DATAS SEGMENT
BCD1 DW 2345H
BCD2 DW 5678H
DATAS ENDS


CODES SEGMENT
ASSUME CS:CODES,DS:DATAS
START:
	MOV AL,BYTE PTR BCD1
    ADD AL,BYTE PTR BCD2
    DAA   ;调整
    MOV BYTE PTR SUM,AL
    
    MOV AL,BYTE PTR BCD1+1
    ADC AL,BYTE PTR BCD2+1
    DAA
    MOV BYTE PTR SUM+1,AL ;存高8位之和
CODES ENDS
END START
```

#### DAS压缩BCD码减法调整指令

`DAS`

* 针对AL中两个组合BCD码数(按二进制运算)之差进行调整，得到正确结果所对应的BCD码数。

### 非压缩BCD码调整指令

* AAA  未组合十进制数加法调整指令
* AAS   未组合十进制数减法调整指令 
* AAM 未组合十进制数乘法调整指令 
* AAD  未组合十进制数除之前调整指令
